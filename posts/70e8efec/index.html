<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>React19_Typescript基础进阶与实战完全指南 | 小五的个人杂货铺</title><meta name="author" content="小五"><meta name="copyright" content="小五"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="基础篇 - 现代化 React 开发入门开发环境与核心概念React 思想与前端演进在 Web 开发的早期，开发者们使用 JavaScript 和 jQuery 等库来为静态的 HTML 页面注入活力。这种方式在处理简单的交互时卓有成效，其核心思路是“命令式”的：开发者需要精确地告诉浏览器“第一步，找到这个 DOM 元素；第二步，修改它的样式；第三步，替换它的文本内容”。当应用程序的规模和复杂度不"><meta property="og:type" content="article"><meta property="og:title" content="React19_Typescript基础进阶与实战完全指南"><meta property="og:url" content="https://xiaowu95.wang/posts/70e8efec/"><meta property="og:site_name" content="小五的个人杂货铺"><meta property="og:description" content="基础篇 - 现代化 React 开发入门开发环境与核心概念React 思想与前端演进在 Web 开发的早期，开发者们使用 JavaScript 和 jQuery 等库来为静态的 HTML 页面注入活力。这种方式在处理简单的交互时卓有成效，其核心思路是“命令式”的：开发者需要精确地告诉浏览器“第一步，找到这个 DOM 元素；第二步，修改它的样式；第三步，替换它的文本内容”。当应用程序的规模和复杂度不"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xiaowu95.wang/img/nba-logo13.jpg"><meta property="article:published_time" content="2025-11-04T09:35:33.000Z"><meta property="article:modified_time" content="2025-11-04T09:35:33.000Z"><meta property="article:author" content="小五"><meta property="article:tag" content="react"><meta property="article:tag" content="前端"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaowu95.wang/img/nba-logo13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "React19_Typescript基础进阶与实战完全指南",
  "url": "https://xiaowu95.wang/posts/70e8efec/",
  "image": "https://xiaowu95.wang/img/nba-logo13.jpg",
  "datePublished": "2025-11-04T09:35:33.000Z",
  "dateModified": "2025-11-04T09:35:33.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "小五",
      "url": "https://xiaowu95.wang"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://xiaowu95.wang/posts/70e8efec/"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="kHfLZxYQ7y3s3AR7gyJDdJkQvGNjQsvopp6N3gEEx0s"><meta name="baidu-site-verification" content="codeva-aVS4F6wAjS"><link rel="manifest" href="/wang-xiaowu/pwa/site.webmanifest"><meta name="msapplication-TileColor" content="#fff"><link rel="apple-touch-icon" sizes="180x180" href="/wang-xiaowu/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/wang-xiaowu/pwa/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/wang-xiaowu/pwa/favicon-16x16.png"><link rel="mask-icon" href="/wang-xiaowu/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),c=window.matchMedia("(prefers-color-scheme: dark)"),r=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(r.matches)a();else if(c.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}c.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?86cb34987e15c900c39e12ebdf08c50d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}(),btf.addGlobalFn("pjaxComplete",(()=>{_hmt.push(["_trackPageview",window.location.pathname])}),"baidu_analytics")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-1MFQ47191J"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1MFQ47191J"),btf.addGlobalFn("pjaxComplete",(()=>{gtag("config","G-1MFQ47191J",{page_path:window.location.pathname})}),"google_analytics")</script><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"M91QAWRVY4",apiKey:"ecc30a5e06136e1cc491685e39801190",indexName:"xiaowu-blog",hitsPerPage:6,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:400,highlightFullpage:!0,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:150,languages:{author:"作者: 小五",link:"链接: ",source:"来源: 小五的个人杂货铺",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!0,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"React19_Typescript基础进阶与实战完全指南",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><script src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/font.css"><style>.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><link rel="stylesheet" href="/css/titleStyle.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css"><style>.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="alternate" href="/atom.xml" title="小五的个人杂货铺" type="application/atom+xml"></head><body><script>window.paceOptions={restartOnPushState:!1},btf.addGlobalFn("pjaxSend",(()=>{Pace.restart()}),"pace_restart")</script><link rel="stylesheet" href="/css/pace.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">554</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/github/"><i class="fa-fw fa-solid fa-address-card"></i> <span>关于我</span></a></div><div class="menus_item"><a class="site-page" href="/ac/"><i class="fa-fw fa-solid fa-wind"></i> <span>便携小空调</span></a></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fa-solid fa-walkie-talkie"></i> <span>博客短记</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i> <span>目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-otter"></i> <span>杂记</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>图库</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i> <span>影视|番剧</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book faa-fload"></i> <span>书单</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad faa-fload"></i> <span>游戏</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i> <span>BiliBili追番</span></a></li><li><a class="site-page child" href="/cinemas/"><i class="fa-fw fa-solid fa-video"></i> <span>BiliBili追剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-user-group"></i> <span>友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-mug-saucer"></i> <span>Website Memo</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://console.leancloud.app/apps"><span>🚀 LeanCloud</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://vercel.com/dashboard"><span>🚀 Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://tongji.baidu.com/main/overview/10000432799/overview/index"><span>🚀 百度统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://ziyuan.baidu.com/dashboard/index"><span>🚀 百度站点管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://analytics.google.com/analytics/web/"><span>🚀 谷歌分析</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://search.google.com/search-console?hl=zh-cn"><span>🚀 谷歌站点管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.google.com/adsense/new/u/0/pub-1375421173355613/home"><span>🚀 谷歌广告联盟</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.algolia.com/"><span>🚀 Algolia</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://sms-activate.org/cn/"><span>🚀 Sms-activate</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://chatgpt.com/"><span>🚀 ChatGPT</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://gemini.google.com/"><span>🚀 Gemini</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://poe.com/"><span>🚀 Poe聚合</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.idc.net/clientarea"><span>🚀 后浪云</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.west.cn/"><span>🚀 西部数据</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://shandianpro.com/#/dashboard"><span>🚀 闪电</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.huojian.homes/"><span>🚀 小火箭</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/winston779/gougou"><span>🚀 狗狗加速</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/nba-logo13.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小五的个人杂货铺</span></a><a class="nav-page-title" href="/"><span class="site-name">React19_Typescript基础进阶与实战完全指南</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i> <span>返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/github/"><i class="fa-fw fa-solid fa-address-card"></i> <span>关于我</span></a></div><div class="menus_item"><a class="site-page" href="/ac/"><i class="fa-fw fa-solid fa-wind"></i> <span>便携小空调</span></a></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fa-solid fa-walkie-talkie"></i> <span>博客短记</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i> <span>目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-otter"></i> <span>杂记</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>图库</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-film"></i> <span>影视|番剧</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book faa-fload"></i> <span>书单</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad faa-fload"></i> <span>游戏</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-brands fa-bilibili"></i> <span>BiliBili追番</span></a></li><li><a class="site-page child" href="/cinemas/"><i class="fa-fw fa-solid fa-video"></i> <span>BiliBili追剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-user-group"></i> <span>友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-mug-saucer"></i> <span>Website Memo</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://console.leancloud.app/apps"><span>🚀 LeanCloud</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://vercel.com/dashboard"><span>🚀 Vercel</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://tongji.baidu.com/main/overview/10000432799/overview/index"><span>🚀 百度统计</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://ziyuan.baidu.com/dashboard/index"><span>🚀 百度站点管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://analytics.google.com/analytics/web/"><span>🚀 谷歌分析</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://search.google.com/search-console?hl=zh-cn"><span>🚀 谷歌站点管理</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.google.com/adsense/new/u/0/pub-1375421173355613/home"><span>🚀 谷歌广告联盟</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.algolia.com/"><span>🚀 Algolia</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://sms-activate.org/cn/"><span>🚀 Sms-activate</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://chatgpt.com/"><span>🚀 ChatGPT</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://gemini.google.com/"><span>🚀 Gemini</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://poe.com/"><span>🚀 Poe聚合</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://www.idc.net/clientarea"><span>🚀 后浪云</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.west.cn/"><span>🚀 西部数据</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://shandianpro.com/#/dashboard"><span>🚀 闪电</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.huojian.homes/"><span>🚀 小火箭</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/winston779/gougou"><span>🚀 狗狗加速</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">React19_Typescript基础进阶与实战完全指南<a class="post-edit-link" href="https://github.com/wang-xiaowu/wang-xiaowu.github.io/issues/new?_posts/前端/react/React19_Typescript基础进阶与实战完全指南.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-04T09:35:33.000Z" title="发表于 2025-11-04 17:35:33">2025-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-04T09:35:33.000Z" title="更新于 2025-11-04 17:35:33">2025-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">25.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>91分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离上一次更新该文章已经过了&quot;,&quot;messageNext&quot;:&quot;天，文章所描述的內容可能已经发生变化，请留意。&quot;,&quot;postUpdate&quot;:&quot;2025-11-04 17:35:33&quot;}" hidden></div><h1 id="基础篇-现代化-React-开发入门"><a href="#基础篇-现代化-React-开发入门" class="headerlink" title="基础篇 - 现代化 React 开发入门"></a>基础篇 - 现代化 React 开发入门</h1><h2 id="开发环境与核心概念"><a href="#开发环境与核心概念" class="headerlink" title="开发环境与核心概念"></a>开发环境与核心概念</h2><h3 id="React-思想与前端演进"><a href="#React-思想与前端演进" class="headerlink" title="React 思想与前端演进"></a>React 思想与前端演进</h3><p>在 Web 开发的早期，开发者们使用 JavaScript 和 jQuery 等库来为静态的 HTML 页面注入活力。这种方式在处理简单的交互时卓有成效，其核心思路是“命令式”的：开发者需要精确地告诉浏览器“第一步，找到这个 DOM 元素；第二步，修改它的样式；第三步，替换它的文本内容”。当应用程序的规模和复杂度不断攀升时，这种直接操作 DOM 的方式很快就会导致代码逻辑混乱，UI 状态与数据状态的同步变得异常困难，代码最终演变成难以维护的“面条代码”。​<br>为了解决这一困境，前端社区引入了 MVC 和 MVVM 等设计模式，诞生了像 AngularJS 和早期 Vue 这样的框架。它们通过数据绑定的方式，将开发者从繁琐的 DOM 操作中解放出来，这是一个巨大的进步。然而，React 的出现，带来了一种更为纯粹和强大的心智模型。​<br>React 的核心思想可以被精炼为一个优雅的公式：<strong>UI &#x3D; f(State)</strong>。​<br>这个公式的含义是，<strong>用户界面（UI）仅仅是应用程序状态（State）的一个函数（f）</strong>。你不再需要思考当数据变化时，应该如何分步去修改界面。你唯一需要做的，就是清晰地描述出“在任何特定状态下，你的界面应该是什么样子”。当状态发生改变时，React 会像一个高效的管家，自动地、以最优的方式去计算出新旧界面之间的差异，并更新真实 DOM 中需要变化的部分。​<br>这种编程范式被称为“<strong>声明式编程</strong>”。它与“命令式编程”形成了鲜明对比。</p><blockquote><p>一个类比：​</p><p>命令式就像是你给朋友导航，告诉他：“从这里出发，开 500 米后左转，经过三个红绿灯后右转...”。​</p><p>声明式则是你直接告诉他你家的地址，让他自己使用 GPS 规划路线。你只关心“结果”（What），而不关心“过程”（How）。</p></blockquote><h3 id="使用-Vite-搭建-React-TypeScript-开发环境"><a href="#使用-Vite-搭建-React-TypeScript-开发环境" class="headerlink" title="使用 Vite 搭建 React + TypeScript 开发环境"></a>使用 Vite 搭建 React + TypeScript 开发环境</h3><p>理论的种子需要实践的土壤才能发芽。要将 React 的思想付诸实践，我们首先需要一个现代化的开发环境。在过去，这通常意味着与复杂的 Webpack 配置进行一番搏斗。但现在，我们有了更优的选择：Vite。​<br>Vite 是一个颠覆性的前端构建工具，它极大地提升了前端的开发体验。其核心优势在于，它利用了现代浏览器原生支持 ES Module 的特性，在开发阶段无需对所有代码进行打包，从而实现了几乎瞬时的服务器启动和快如闪电的热模块更新（HMR）。这意味着您修改代码后，几乎可以立即在浏览器中看到变化，这极大地加速了开发和调试的反馈循环。​<br>搭建一个基于 Vite 的 React + TypeScript 项目非常简单。整个过程始于您的终端（或命令行工具）。​<br>首先，运行创建项目的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest​</span><br></pre></td></tr></table></figure><p>执行该命令后，Vite 会启动一个交互式的脚手架，引导您完成项目的配置。您需要依次输入项目名称，然后使用键盘方向键选择 <code>React</code> 作为开发框架，再选择 <code>TypeScript</code> 作为变体。​<br>当脚手架完成文件生成后，根据终端的提示，进入项目目录并安装所需的依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换到你的项目目录，例如 &quot;my-react-app&quot;cd my-react-app​</span><br><span class="line">​</span><br><span class="line"># 使用 npm 安装依赖​</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>万事俱备，现在只需启动开发服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>片刻之后，您会看到终端输出一个本地服务器地址（通常是 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://localhost:5173/">http://localhost:5173</a> ）<br>在浏览器中打开它，一个崭新的React 应用便呈现在您眼前。​<br>这个由 Vite 生成的项目结构清晰明了。我们大部分的工作都将在 src 目录下进行，其中 App.tsx 是应用的根组件，而 main.tsx 则是将根组件挂载到 index.html 页面上的入口文件。</p><h3 id="深入-JSX-语法与实践技巧"><a href="#深入-JSX-语法与实践技巧" class="headerlink" title="深入 JSX 语法与实践技巧"></a>深入 JSX 语法与实践技巧</h3><p>初次接触 React 代码时，最引人注目的无疑是 JSX。它是一种允许我们在 JavaScript 文件中编写类似 HTML 结构代码的语法扩展。看到它，请务必记住一个关键点：<strong>JSX 不是 HTML，而是 JavaScript 的一种特殊语法</strong>。​<br>实际上，我们编写的每一行 JSX 代码，在经过编译后，都会被转换为一个普通的 JavaScript 函数调用——<code>React.createElement()</code>。例如，这样一行 JSX：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;title&quot;</span>&gt;<span class="title class_">Hello</span>, <span class="title class_">React</span>&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>其本质是下面这行代码的“语法糖”：​</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, &#123; <span class="attr">className</span>: <span class="string">&#x27;title&#x27;</span> &#125;, <span class="string">&#x27;Hello, React&#x27;</span>);​</span><br></pre></td></tr></table></figure><p>理解了 JSX 的本质是 JavaScript，我们就能更好地掌握它的语法规则。因为它是 JS，所以它具备了 JavaScript 的全部动态能力。我们可以使用大括号 {} 在 JSX 中嵌入任何有效的 JavaScript 表达式，无论是变量、数学运算，还是函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">level</span>: <span class="number">5</span> &#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> greeting = (​</span><br><span class="line">  &lt;h1&gt;​</span><br><span class="line">    <span class="title class_">Welcome</span>, &#123;user.<span class="property">name</span>.<span class="title function_">toUpperCase</span>()&#125;! <span class="title class_">Your</span> access level is &#123;user.<span class="property">level</span> + <span class="number">1</span>&#125;.​</span><br><span class="line">  &lt;/h1&gt;​</span><br><span class="line">);​</span><br></pre></td></tr></table></figure><p>在使用 JSX 描述界面结构时，有几条核心规则需要遵守。首先，一个组件返回的 JSX 必须拥有一个单一的根元素。如果想返回并列的多个元素，可以用一个外层 div 包裹它们。但更好的做法是使用 Fragment (&lt;&gt;...&lt;&#x2F;&gt;)，它允许我们对元素进行分组，而不会在最终的 DOM 结构中添加任何额外的节点。​<br>其次，由于 JSX 最终会被编译成 JavaScript，一些 HTML 属性的写法需要调整以避免与 JavaScript 的保留关键字冲突。最常见的例子就是 <code>class</code> 属性需要写成 <code>className</code>，<code>for</code> 属性需要写成 <code>htmlFor</code>。同样，事件名也遵循驼峰命名法，如 <code>onclick</code> 变为 <code>onClick</code>。</p><h3 id="函数式组件与-Class-组件对比"><a href="#函数式组件与-Class-组件对比" class="headerlink" title="函数式组件与 Class 组件对比"></a>函数式组件与 Class 组件对比</h3><p>在 React 中，定义组件主要有两种历史悠久的方式：Class 组件和函数式组件。虽然您在一些旧的项目或文档中仍会见到 Class 组件的身影，但理解它们之间的差异，将帮助您清晰地认识到为何整个 React 生态已经全面拥抱了函数式组件。​<br>Class 组件是早期 React 中创建可复用、有状态组件的主要方式。它基于 ES6 的 class 语法，需要继承 <code>React.Component</code>，并且通过 <code>this.state</code> 来管理内部状态，通过 <code>this.setState()</code> 来更新状态，UI 的描述则必须放在 <code>render()</code> 方法中。​<br>让我们看一个 Class 组件实现的计数器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassCounter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;​</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;​</span><br><span class="line">​</span><br><span class="line">  handleIncrement = <span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;​</span><br><span class="line">    <span class="keyword">return</span> (​</span><br><span class="line">      &lt;div&gt;​</span><br><span class="line">        &lt;p&gt;<span class="title class_">Count</span>: &#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>&#125;&lt;/p&gt;​</span><br><span class="line">        &lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleIncrement</span>&#125;&gt;<span class="title class_">Increment</span>&lt;/button&gt;​</span><br><span class="line">      &lt;/div&gt;​</span><br><span class="line">    );​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的结构相对固定，但也带来了额外的“模板代码”和对 this 关键字的复杂心智负担。​<br>与此相对，函数式组件则是一个更为简洁和直观的范式。在早期，函数式组件仅仅是接收 <code>props</code> 并返回 JSX 的“哑”组件，无法拥有自己的状态。然而，自 React 16.8 引入 <strong>Hooks</strong> 之后，一切都改变了。​<br>Hooks（例如 <code>useState</code>）让函数式组件也能拥有状态和其他 React 特性。现在，我们可以用一种更简单、更符合 JavaScript 函数式编程思想的方式来重写上面的计数器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionalCounter</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleIncrement</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;p&gt;<span class="title class_">Count</span>: &#123;count&#125;&lt;/p&gt;​</span><br><span class="line">      &lt;button onClick=&#123;handleIncrement&#125;&gt;<span class="title class_">Increment</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两相对比，函数式组件的优势显而易见。它更加简洁，代码量更少，并且完全消除了 this 关键字带来的困扰。更重要的是，Hooks 的设计使得状态逻辑的复用变得异常简单，我们可以轻松地将相关逻辑封装在自定义 Hook 中，这在 Class 组件的时代是难以想象的。​<br>正是由于这些压倒性的优势，函数式组件与 <strong>Hooks</strong> 已成为现代 React 开发的绝对标准。在本课程的后续所有章节中，我们都将完全采用这种现代化的范式来构建我们的应用。</p><h2 id="组件化开发核心"><a href="#组件化开发核心" class="headerlink" title="组件化开发核心"></a>组件化开发核心</h2><p>现在，我们将正式进入组件化开发的世界。组件是 React 应用的基石，理解如何构建组件、如何让它们之间有效通信，是掌握 React 的关键。本章将深入探讨组件的输入（<strong>Props</strong>）、内部状态（<strong>State</strong>）以及如何响应用户交互。</p><h3 id="Props-与组件通信"><a href="#Props-与组件通信" class="headerlink" title="Props 与组件通信"></a>Props 与组件通信</h3><p>任何有意义的 React 应用都是由多个组件构成的组件树。这些组件并非孤立存在，它们需要相互协作，传递信息，共同构成完整的用户界面。实现组件间通信最基础、最核心的机制，就是 Props。​<br>Props，是 “properties” 的缩写，其作用与 JavaScript 函数的参数非常相似。如果说组件是一个函数，那么 Props 就是这个函数接收的参数。父组件通过 Props 将数据和功能传递给子组件，从而实现对子组件的配置和控制。​<br>让我们来看一个简单的例子。假设我们有一个 <code>Welcome</code> 组件，我们希望它能向不同的用户显示欢迎信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Welcome.tsx (子组件)​</span></span><br><span class="line">type <span class="title class_">WelcomeProps</span> = &#123;​</span><br><span class="line">  <span class="attr">name</span>: string;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Welcome</span> = (<span class="params">props: WelcomeProps</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// App.tsx (父组件)​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;<span class="title class_">Welcome</span> name=<span class="string">&quot;Sara&quot;</span> /&gt;​</span><br><span class="line">      &lt;<span class="title class_">Welcome</span> name=<span class="string">&quot;Cahal&quot;</span> /&gt;​</span><br><span class="line">      &lt;<span class="title class_">Welcome</span> name=<span class="string">&quot;Edite&quot;</span> /&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>App</code> 组件作为父组件，三次渲染了 <code>Welcome</code> 子组件。每次渲染时，它都通过一个名为 <code>name</code> 的 Prop，向 <code>Welcome</code> 组件传递了不同的值。<code>Welcome</code> 组件则在其函数参数中接收这个 <code>props</code> 对象，并读取 <code>props.name</code> 来动态地渲染内容。​<br>关于 Props，有一个至关重要的原则必须牢记：<strong>Props 是只读的（Read-Only）</strong>。子组件绝不能尝试修改它接收到的 Props。所有 Props 都使得组件的输出仅依赖于输入，这使得组件的行为变得非常可预测。这种自顶而下的数据流动方式，通常被称为“单向数据流”。数据就像瀑布一样，从组件树的顶端流向末端，这使得追踪数据的来源和变化变得非常简单，极大地降低了应用的复杂度。​<br>除了传递自定义数据，React 还提供了一个特殊的 Prop：<code>children</code>。这个 Prop 的值不是通过属性赋值，而是通过组件的闭合标签之间的内容来决定的。它使得我们可以轻松地创建具有“插槽”功能的容器类组件。​<br>设想一个 <code>Card</code> 组件，它需要一个统一的边框和阴影样式，但内部的内容是灵活多变的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.tsx​</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// React.PropsWithChildren 是一个辅助类型，它自动包含了 children prop​</span></span><br><span class="line">type <span class="title class_">CardProps</span> = <span class="title class_">React</span>.<span class="property">PropsWithChildren</span>&lt;&#123;&#125;&gt;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Card</span> = (<span class="params">&#123; children &#125;: CardProps</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div style=&#123;&#123; <span class="attr">border</span>: <span class="string">&#x27;1px solid #ccc&#x27;</span>, <span class="attr">padding</span>: <span class="string">&#x27;16px&#x27;</span>, <span class="attr">borderRadius</span>: <span class="string">&#x27;8px&#x27;</span> &#125;&#125;&gt;​</span><br><span class="line">      &#123;children&#125;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// App.tsx​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;<span class="title class_">Card</span>&gt;​</span><br><span class="line">      &#123;<span class="comment">/* 👇 这里的所有内容都会作为 children Prop 传递给 Card 组件 */</span>&#125;​</span><br><span class="line">      &lt;h2&gt;<span class="title class_">Article</span> <span class="title class_">Title</span>&lt;/h2&gt;​</span><br><span class="line">      &lt;p&gt;<span class="title class_">This</span> is the content <span class="keyword">of</span> the article inside the card.&lt;/p&gt;​</span><br><span class="line">    &lt;/<span class="title class_">Card</span>&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>props.children</code>，<code>Card</code> 组件就好像一个相框，它定义了相框的样式，但里面的照片（内容）则由使用它的父组件来决定。这是实现组件组合和复用的强大模式。</p><h3 id="使用-TypeScript-定义-Props-类型"><a href="#使用-TypeScript-定义-Props-类型" class="headerlink" title="使用 TypeScript 定义 Props 类型"></a>使用 TypeScript 定义 Props 类型</h3><p>随着应用规模的扩大，组件的 Props 可能会变得越来越复杂。如果我们不小心传递了错误类型的数据，或者遗漏了某个必需的 Prop，程序就可能在运行时出错。为了在开发阶段就避免这类问题，我们引入了 TypeScript。​<br>为组件的 Props 添加类型定义，就像是为组件签署了一份“契约”。这份契约明确规定了该组件需要哪些 Props，以及每个 Prop 的数据类型是什么。这不仅能提供强大的编辑器自动补全和错误检查，还让代码本身成为了最好的文档。​<br>在 TypeScript 中，我们通常使用 <code>type</code> 或 <code>interface</code> 关键字来定义 Props 的类型。对于组件 Props 而言，两者在功能上几乎可以互换，选择哪一个更多是团队的风格偏好。​<br>让我们为一个更复杂的用户资料卡片组件 <code>UserProfile</code> 添加类型定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserProfile.tsx​</span></span><br><span class="line">type <span class="title class_">UserProfileProps</span> = &#123;​</span><br><span class="line">  <span class="attr">name</span>: string;​</span><br><span class="line">  <span class="attr">age</span>: number;​</span><br><span class="line">  <span class="attr">isVerified</span>: boolean;​</span><br><span class="line">  hobbies?: string[]; <span class="comment">// &#x27;?&#x27; 表示这是一个可选的 Prop​</span></span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserProfile</span> = (<span class="params">props: UserProfileProps</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, isVerified, hobbies &#125; = props;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;h3&gt;&#123;name&#125; &#123;isVerified ? <span class="string">&#x27;✔️&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;&lt;/h3&gt;​</span><br><span class="line">      &lt;p&gt;<span class="title class_">Age</span>: &#123;age&#125;&lt;/p&gt;​</span><br><span class="line">      &#123;hobbies &amp;&amp; hobbies.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; (​</span><br><span class="line">        &lt;p&gt;<span class="title class_">Hobbies</span>: &#123;hobbies.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>)&#125;&lt;/p&gt;​</span><br><span class="line">      )&#125;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// App.tsx​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;<span class="title class_">UserProfile</span> ​</span><br><span class="line">      name=<span class="string">&quot;John Doe&quot;</span>​</span><br><span class="line">      age=&#123;<span class="number">30</span>&#125;​</span><br><span class="line">      isVerified=&#123;<span class="literal">true</span>&#125;​</span><br><span class="line">      hobbies=&#123;[<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;coding&#x27;</span>]&#125;​</span><br><span class="line">    /&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>UserProfileProps</code> 类型契约清晰地描述了 <code>UserProfile</code> 组件的“API”：它必须接收 <code>name</code>, <code>age</code>, <code>isVerified</code> 三个 Prop，并且它们的类型分别是 <code>string</code>, <code>number</code>, <code>boolean</code>。同时，它还可以选择性地接收一个名为 hobbies 的字符串数组。​<br>如果我们在使用 <code>UserProfile</code> 组件时违反了这个契约，TypeScript 编译器和我们的代码编辑器会立刻给出错误提示，例如：​<br>• <code>&lt;UserProfile name=&quot;Jane&quot; isVerified=&#123;false&#125; /&gt;</code><br><userprofile name="Jane" isverified="{false}/">&#x2F;&#x2F; 错误：属性 &quot;age&quot; 在类型中缺失。​<br>• <code>&lt;UserProfile name=&quot;Jane&quot; age=&quot;25&quot; isVerified=&#123;false&#125; /&gt;</code><br><userprofile name="Jane" age="25" isverified="{false}/">&#x2F;&#x2F; 错误：不能将类型 &quot;string&quot; 分配给类型 &quot;number&quot;。​<br>这种即时的反馈机制极大地提升了代码的健壮性和开发效率。</userprofile></userprofile></p><h3 id="事件处理与合成事件系统"><a href="#事件处理与合成事件系统" class="headerlink" title="事件处理与合成事件系统"></a>事件处理与合成事件系统</h3><p>我们已经了解了数据如何通过 Props 从父组件流向子组件。但如果子组件需要将信息传递回父组件呢？比如，当用户点击子组件中的一个按钮时，父组件的状态需要发生改变。这种自下而上的通信，通常通过事件处理来实现。​<br>在 React 中处理事件的方式与在原生 DOM 中非常相似，但有几个细微的差别：​</p><ol><li>React 事件的命名采用驼峰式（camelCase），而不是纯小写。例如，<code>onclick</code> 变为 <code>onClick</code>。​</li><li>我们传递的是一个函数作为事件处理程序，而不是一个字符串。​</li></ol><p>一个基本的事件处理如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Button clicked!&#x27;</span>);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;​</span><br><span class="line">      <span class="title class_">Click</span> <span class="title class_">Me</span>​</span><br><span class="line">    &lt;/button&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，我们将 <code>handleClick</code> 函数作为 Prop 传递给了 <code>&lt;button&gt;</code> 元素的 <code>onClick</code> 属性。当用户点击按钮时，React 会调用这个函数。​<br>要实现子组件到父组件的通信，核心思想就是<strong>将父组件中的函数作为 Prop 传递给子组件</strong>。父组件定义了行为（做什么），子组件则决定了何时触发该行为（何时调用该函数）。​<br>让我们构建一个场景：父组件 <code>Dashboard</code> 需要知道其子组件 <code>LoginButton</code> 何时被点击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoginButton.tsx (子组件)​</span></span><br><span class="line">type <span class="title class_">LoginButtonProps</span> = &#123;​</span><br><span class="line">  <span class="comment">// 我们定义一个 onLoginClick 的 Prop，它的类型是一个不接收参数、无返回值的函数​</span></span><br><span class="line">  <span class="attr">onLoginClick</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span>; ​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LoginButton</span> = (<span class="params">&#123; onLoginClick &#125;: LoginButtonProps</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 当按钮被点击时，调用从父组件传来的 onLoginClick 函数​</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onLoginClick&#125;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Dashboard.tsx (父组件)​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Dashboard</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleUserLogin</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User is trying to log in from the Dashboard!&#x27;</span>);​</span><br><span class="line">    <span class="comment">// 在这里可以处理登录逻辑，比如更新父组件的状态​</span></span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;h1&gt;<span class="title class_">Welcome</span> to the <span class="title class_">Dashboard</span>&lt;/h1&gt;​</span><br><span class="line">      &#123;<span class="comment">/* 将 handleUserLogin 函数作为 Prop 传递给子组件 */</span>&#125;​</span><br><span class="line">      &lt;<span class="title class_">LoginButton</span> onLoginClick=&#123;handleUserLogin&#125; /&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这种模式，<code>LoginButton</code> 组件保持了其通用性，它只负责渲染一个按钮并报告点击事件，而不关心点击后具体会发生什么。所有的业务逻辑都保留在了父组件 <code>Dashboard</code> 中，实现了清晰的职责分离。​<br>值得一提的是，我们传递给 <code>onClick</code> 等事件处理程序的事件对象 <code>e</code>，并不是原生的浏览器事件对象，而是一个 <strong>合成事件（SyntheticEvent）</strong> 对象。这是 React 对原生事件的一个跨浏览器包装器。它抹平了不同浏览器在事件系统上的差异，使得我们写的事件处理代码能够在所有浏览器中表现一致，无需担心兼容性问题。</p><h3 id="状态管理入门：useState-Hook-详解"><a href="#状态管理入门：useState-Hook-详解" class="headerlink" title="状态管理入门：useState Hook 详解"></a>状态管理入门：useState Hook 详解</h3><p>Props 是从外部传入且不可变的，而 State 则是组件内部自己管理的数据，并且它是可变的。在函数式组件中，我们用来赋予组件状态能力的工具，就是 React 最基础也最重要的 Hook 之一：<code>useState</code>。​<br><code>useState</code> 的调用本身非常简单，它接收一个参数作为状态的初始值，然后返回一个包含两个元素的数组。我们通常使用 JavaScript 的数组解构语法来接收这两个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 1. 调用 useState，传入初始值 0​</span></span><br><span class="line">  <span class="comment">// 2. 解构返回的数组​</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// ...​</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们来仔细解读解构出来的这两个成员：​</p><ol><li>count：这是状态变量。它是在每次组件渲染时，持有当前状态值的常量。在上面的例子中，它第一次渲染时的值是我们传入的初始值 0。​</li><li>setCount：这是更新函数。它是我们用来改变 count 状态的唯一途径。直接修改 count 的值（例如 count &#x3D; count + 1）是无效的，并且严重违反了 React 的原则。​<br>当我们调用更新函数（如 setCount(1)）时，React 会做两件重要的事情：​</li><li>它会计划一次对状态的更新，将新的状态值保存起来。​</li><li>它会触发该组件的一次重新渲染（re-render）。​<br>在下一次渲染发生时，useState 会返回更新后的最新状态值。正是这个“<strong>状态更新 → 触发重新渲染 → 使用新状态渲染UI</strong>”的循环，构成了 React 动态交互的核心。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleIncrement</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="comment">// 调用更新函数，传入新的状态值​</span></span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;p&gt;<span class="title class_">Current</span> count <span class="attr">is</span>: &#123;count&#125;&lt;/p&gt;​</span><br><span class="line">      &#123;<span class="comment">/* 点击按钮时，会触发状态更新和组件重新渲染 */</span>&#125;​</span><br><span class="line">      &lt;button onClick=&#123;handleIncrement&#125;&gt;<span class="title class_">Increment</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用 <code>useState</code> 时，一个核心原则是状态的<strong>不可变性（Immutability）</strong>。对于对象或数组这样的引用类型，我们不应该直接修改它们内部的属性，而应该总是创建一个新的对象或数组来替换旧的。这是因为 React 通过浅比较来判断状态是否发生了变化。如果你只是修改了原对象的属性，对象的引用地址并未改变，React 可能会认为状态没有变化，从而跳过重新渲染。</p><blockquote><p>错误的做法 (直接修改) ❌:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = <span class="title function_">useState</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleAgeIncrement</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    user.<span class="property">age</span> += <span class="number">1</span>; <span class="comment">// 直接修改了原对象​</span></span><br><span class="line">    <span class="title function_">setUser</span>(user); <span class="comment">// 传入的还是旧的引用，React 可能不会更新​</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正确的做法 (创建新对象) ✅:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = <span class="title function_">useState</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;);​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleAgeIncrement</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="comment">// 使用展开语法(...)创建一个新对象，并覆盖 age 属性​</span></span><br><span class="line">    <span class="keyword">const</span> newUser = &#123; ...user, <span class="attr">age</span>: user.<span class="property">age</span> + <span class="number">1</span> &#125;;​</span><br><span class="line">&gt;.    <span class="title function_">setUser</span>(newUser);​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>此外，更新函数还支持接收一个函数作为参数，这种形式被称为函数式更新。这个函数会接收到前一个状态作为参数，并返回新的状态。当新的状态依赖于旧的状态时，使用函数式更新是更安全、更推荐的做法，它可以避免在快速连续的更新中由于闭包导致的状态陈旧问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当新状态依赖于旧状态时，推荐使用函数式更新​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleIncrementByTwo</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);​</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="条件渲染与列表渲染-key-的重要性"><a href="#条件渲染与列表渲染-key-的重要性" class="headerlink" title="条件渲染与列表渲染 (key 的重要性)"></a>条件渲染与列表渲染 (key 的重要性)</h3><p>现在我们的组件已经拥有了可以变化的状态，下一步就是根据这些状态来动态地决定界面应该呈现什么内容。这就是动态渲染，它主要分为两种场景：条件渲染和列表渲染。​<br>条件渲染，顾名思义，是根据不同的条件来渲染不同的 JSX。由于 JSX 本身就是 JavaScript，我们可以自如地运用 JavaScript 的条件控制语句。​<br>在 JSX 中，最常用的是<strong>三元运算符 (? :)</strong> 和<strong>逻辑与运算符 (&amp;&amp;)</strong>。​<br>三元运算符非常适合处理 <code>if-else</code> 这样的二选一场景。例如，根据用户是否登录，显示不同的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">AuthStatus</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [isLoggedIn, setIsLoggedIn] = <span class="title function_">useState</span>(<span class="literal">false</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &#123;isLoggedIn ? <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Please log in.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;​</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setIsLoggedIn</span>(!isLoggedIn)&#125;&gt;<span class="title class_">Toggle</span> <span class="title class_">Login</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而逻辑与 <code>&amp;&amp;</code> 运算符则是一个巧妙的捷径，用于处理“如果条件为真，则渲染某个元素，否则什么都不渲染”的场景。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Mailbox</span> = (<span class="params">&#123; unreadMessages &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>​</span><br><span class="line">      &#123;unreadMessages.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp;​</span><br><span class="line">        &lt;h2&gt;​</span><br><span class="line">          <span class="title class_">You</span> have &#123;unreadMessages.<span class="property">length</span>&#125; unread messages.​</span><br><span class="line">        &lt;/h2&gt;​</span><br><span class="line">      &#125;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;​</span><br></pre></td></tr></table></figure><p>当 <code>unreadMessages.length &gt; 0</code> 为真时，表达式会返回 <code>&amp;&amp;</code> 右侧的 <code>&lt;h2&gt;</code> 元素；如果为假，则表达式直接返回 <code>false</code>，而 React 不会渲染布尔值 <code>false</code>。​<br>列表渲染则涉及将数组中的每一项数据转换并渲染为一组 UI 元素。在 JavaScript 中，将数组转换为另一个数组最自然的方式就是使用 <code>Array.prototype.map()</code> 方法，React 中的列表渲染正是利用了这一点。​<br>假设我们有一个待办事项数组，需要将它们渲染成一个列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [​</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;a1&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Learn React&#x27;</span> &#125;,​</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;b2&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Build a project&#x27;</span> &#125;,​</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;c3&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Deploy the project&#x27;</span> &#125;,​</span><br><span class="line">];​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TodoList</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;ul&gt;​</span><br><span class="line">      &#123;todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> (​</span><br><span class="line">        &lt;li key=&#123;todo.<span class="property">id</span>&#125;&gt;​</span><br><span class="line">          &#123;todo.<span class="property">text</span>&#125;​</span><br><span class="line">        &lt;/li&gt;​</span><br><span class="line">      ))&#125;​</span><br><span class="line">    &lt;/ul&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码中，请特别注意 <code>&lt;li&gt;</code> 元素上的 <code>key</code> 属性。这是列表渲染中一个至关重要且不可或缺的部分。​</p><p><strong><code>key</code> 的重要性​</strong></p><p><code>key</code> 是 React 用来识别列表中各个元素的“身份证”。当列表数据发生变化（例如增、删、改、排序）时，React 的协调算法（Reconciliation）会通过 <code>key</code> 来高效地比对新旧两棵虚拟 DOM 树。它会根据 key 来判断哪些元素是新创建的、哪些被删除了、哪些只是移动了位置。​</p><ul><li>一个稳定且唯一的 <code>key</code> 能帮助 React 最大限度地复用已有的 DOM 元素和组件实例，从而极大地提升性能。​</li><li>如果不提供 <code>key</code>，React 会在控制台给出警告，并且在列表更新时可能会出现不可预测的 UI bug 和性能问题。​</li><li>使用数组的索引 (index) 作为 <code>key</code> 是一种常见的反模式，应当极力避免。因为当列表项的顺序发生改变时（例如在数组开头插入一个新元素），所有后续元素的索引都会改变。这会让 React 误以为是元素自身的内容发生了大规模变化，从而导致不必要的重新渲染，甚至丢失组件内部的状态（如输入框的内容）。<blockquote><p>最理想的 <code>key</code> 值，是数据项中本身就带有的、独一无二且不随时间变化的字符串或数字，比如数据库中的 <code>id</code></p></blockquote></li></ul><h2 id="深入-Hooks-与生命周期"><a href="#深入-Hooks-与生命周期" class="headerlink" title="深入 Hooks 与生命周期"></a>深入 Hooks 与生命周期</h2><p>在前两章中，我们聚焦于一个组件的“纯粹”职责：接收 Props，管理 State，并根据它们返回一段描述 UI 的 JSX。这个过程是封闭且可预测的。然而，在真实的应用程序中，组件常常需要与“外部世界”进行通信——它可能需要从服务器获取数据，需要直接操作浏览器 DOM，或者需要设置定时器和订阅事件。这些与组件渲染主流程无关的操作，我们称之为“副作用”（Side Effects）。本章将深入探讨用于管理这些<strong>副作用</strong>的核心 Hook——<code>useEffect</code>，以及其他几个功能强大的 Hooks。</p><h3 id="副作用处理：useEffect-Hook-详解-挂载、更新、卸载"><a href="#副作用处理：useEffect-Hook-详解-挂载、更新、卸载" class="headerlink" title="副作用处理：useEffect Hook 详解 (挂载、更新、卸载)"></a>副作用处理：useEffect Hook 详解 (挂载、更新、卸载)</h3><p><code>useEffect</code> 是 React 提供给我们的一个“逃生舱口”，它允许我们在函数式组件中执行副作用操作。其设计的核心理念是将副作用逻辑与渲染逻辑分离开来，并确保这些副作用操作不会在渲染期间阻塞浏览器，而是在组件完成渲染之后异步执行。​<br>一个 useEffect 的基本结构包含一个回调函数和（可选的）一个依赖项数组：​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123; /* 副作用逻辑 / &#125;, [/ 依赖项 */]);​</span><br></pre></td></tr></table></figure><p>通过控制第二个参数——依赖项数组，我们可以精确地模仿传统 Class 组件中生命周期方法的行为，如组件的挂载、更新和卸载。</p><h4 id="模拟组件挂载-Mount"><a href="#模拟组件挂载-Mount" class="headerlink" title="模拟组件挂载 (Mount)"></a>模拟组件挂载 (Mount)</h4><p>当我们需要副作用仅仅在组件第一次渲染到屏幕上之后执行一次，且之后不再重复执行时，我们可以向 useEffect 传递一个空的依赖项数组 <code>[]</code>。这等同于 Class 组件中的 <code>componentDidMount</code>。​<br>这是执行一次性设置操作的理想场所，例如：从 API 获取初始数据，或者设置一个全局的事件监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserProfile</span> = (<span class="params">&#123; userId &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = <span class="title function_">useState</span>(<span class="literal">null</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件已挂载，开始获取数据...&#x27;</span>);​</span><br><span class="line">    <span class="comment">// 假设 fetchUserData 是一个获取用户数据的异步函数​</span></span><br><span class="line">    <span class="title function_">fetchUserData</span>(userId).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;​</span><br><span class="line">      <span class="title function_">setUser</span>(data);​</span><br><span class="line">    &#125;);​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 依赖项数组为空，此 effect 仅在初始渲染后运行一次​</span></span><br><span class="line">  &#125;, []); ​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;​</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;​</span><br><span class="line">  &#125;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="模拟组件更新-Update"><a href="#模拟组件更新-Update" class="headerlink" title="模拟组件更新 (Update)"></a>模拟组件更新 (Update)</h4><p>在某些场景下，我们希望副作用在每次组件渲染或特定数据变化后都重新执行。例如，我们希望网页的标题能实时反映出当前计数器的值。如果不提供第二个参数，effect 将在每次渲染后都执行。如果提供了依赖项数组，则只有在数组中的值发生变化时，effect 才会再次执行。这部分我们将在下一节详述。​<br>​</p><h4 id="模拟组件卸载-Unmount-与-清理副作用​"><a href="#模拟组件卸载-Unmount-与-清理副作用​" class="headerlink" title="模拟组件卸载 (Unmount) 与 清理副作用​"></a><strong>模拟组件卸载 (Unmount) 与 清理副作用​</strong></h4><p>副作用操作常常会产生一些需要“清理”的后续工作，以避免内存泄漏或不必要的行为。例如，如果我们设置了一个定时器，或者订阅了一个事件，就需要在组件被销毁时取消定时器或退订事件。​<br><code>useEffect</code> 通过其回调函数的返回值来优雅地解决了这个问题。如果 <code>useEffect</code> 的回调函数返回了另一个函数，那么这个返回的函数就被视为清理函数。React 会在组件从 UI 中移除（卸载）之前，以及在下一次 effect 即将重新执行之前，调用这个清理函数。这等同于 Class 组件中的 <code>componentWillUnmount</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Timer</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [seconds, setSeconds] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="comment">// 设置副作用：每秒增加 seconds 的值​</span></span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick&#x27;</span>);​</span><br><span class="line">      <span class="title function_">setSeconds</span>(<span class="function"><span class="params">s</span> =&gt;</span> s + <span class="number">1</span>);​</span><br><span class="line">    &#125;, <span class="number">1000</span>);​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回一个清理函数​</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;​</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件即将卸载，清理定时器...&#x27;</span>);​</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalId); <span class="comment">// 在组件卸载时清除定时器​</span></span><br><span class="line">    &#125;;​</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组确保定时器只设置和清理一次​</span></span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Timer: &#123;seconds&#125;s<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，即使用户切换页面导致 <code>Timer</code> 组件被销毁，我们也能确保定时器被妥善清理，不会在后台继续运行。</p><h3 id="useEffect-的依赖项数组与常见陷阱"><a href="#useEffect-的依赖项数组与常见陷阱" class="headerlink" title="useEffect 的依赖项数组与常见陷阱"></a>useEffect 的依赖项数组与常见陷阱</h3><p>依赖项数组是 useEffect 的“指挥官”，它精确地告诉 React：“请在这些值发生变化时，才重新执行我的副作用逻辑”。正确地使用依赖项数组是编写健壮、高效的 React 组件的关键。​<br>数组中的每个值，在每次组件渲染后都会被 React 进行一次浅比较（使用 Object.is）。只有当至少一个值与上一次渲染时的值不同时，effect 才会重新运行。​<br>让我们回顾一下它的三种行为模式：​</p><ul><li>不提供数组：<code>useEffect(() =&gt; &#123; ... &#125;)</code> -&gt; 每次渲染后都执行。​</li><li>提供空数组：<code>useEffect(() =&gt; &#123; ... &#125;, [])</code> -&gt; 仅在第一次渲染后执行。​</li><li>提供含值的数组：<code>useEffect(() =&gt; &#123; ... &#125;, [propA, stateB])</code> -&gt; 第一次渲染后执行，并且在 propA 或 stateB 发生变化后的每次渲染中再次执行。​<br>核心原则： 依赖项数组应该包含所有在 effect 函数内部被引用的、且来自于组件作用域的变量（如 props, state, 或自定义函数）。​<br>忽略这个原则会导致一些非常隐蔽和难以调试的 bug，其中最常见的有两个：​<br>陷阱一：无限循环​<br>当你在一个 effect 中更新了某个 state，而这个 state 又恰好是该 effect 的依赖项时，就会产生一个无限循环。</li></ul><blockquote><p>错误示例 ❌:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="comment">// 每次 count 变化，都会执行这里，然后又导致 count 变化...​</span></span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);​</span><br><span class="line"> &#125;, [count]); <span class="comment">// 依赖于 count</span></span><br></pre></td></tr></table></figure><p>其执行流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`count` 变化 -\&gt; 触发渲染 -\&gt; 渲染后执行 effect -\&gt; `setCount` 更新 `count` -\&gt; `count` 变化 -\&gt; 无限循环...​</span><br></pre></td></tr></table></figure></blockquote><p><strong>陷阱二：陈旧的闭包​</strong><br>这是更隐蔽的一个问题。如果你的 effect 引用了某个 state 或 prop，但你忘记将它加入依赖项数组，那么 effect 函数将“捕获”该变量在第一次渲染时的值，并且永远不会获取到它最新的值。</p><blockquote><p>错误示例 ❌:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ChatRoom</span> = (<span class="params">&#123; roomId &#125;</span>) =&gt; &#123;​</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Connecting to room <span class="subst">$&#123;roomId&#125;</span>...`</span>);​</span><br><span class="line">    <span class="comment">// ... 连接逻辑 ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;​</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Disconnecting from room <span class="subst">$&#123;roomId&#125;</span>...`</span>); <span class="comment">// 这里的 roomId 永远是旧的​</span></span><br><span class="line">    &#125;;</span><br><span class="line">   &#125;, []); <span class="comment">// 忘记将 roomId 加入依赖项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这个例子中，如果 `roomId` 这个 prop 发生了变化，组件虽然会重新渲染，但由于依赖项是 `[]`，旧的 effect 不会被清理，新的 effect 也不会执行。清理函数中的 `roomId` 将永远是组件第一次挂载时的那个旧值。​</span><br></pre></td></tr></table></figure></blockquote><p>幸运的是，我们不必手动检查依赖项。官方的 <code>eslint-plugin-react-hooks</code> 插件能够自动分析你的 useEffect 代码，并以警告或错误的形式提示你添加缺失的依赖项，或移除多余的依赖项。强烈建议在所有项目中启用此 ESLint 规则。</p><h3 id="使用-useRef-访问-DOM-和存储可变值"><a href="#使用-useRef-访问-DOM-和存储可变值" class="headerlink" title="使用 useRef 访问 DOM 和存储可变值"></a>使用 useRef 访问 DOM 和存储可变值</h3><p>useState 和 useEffect 满足了我们大部分的需求，但还有一类特殊场景：当我们需要一个值在多次渲染之间保持持久，但它的改变不应该触发组件的重新渲染时。为了应对这个场景，React 提供了 useRef Hook。​<br>useRef 返回一个可变的 ref 对象，该对象只有一个 .current 属性。你可以将任何值存放在myRef.current 中。​</p><h4 id="useRef-主要有两个用途：​"><a href="#useRef-主要有两个用途：​" class="headerlink" title="useRef 主要有两个用途：​"></a>useRef 主要有两个用途：​</h4><h5 id="访问-DOM-元素"><a href="#访问-DOM-元素" class="headerlink" title="访问 DOM 元素"></a>访问 DOM 元素</h5><p>这是 useRef 最常见的用途。在某些情况下，我们确实需要跳出 React 的声明式世界，去直接操作一个底层的 DOM 节点，例如：管理表单焦点的切换、触发动画、或者集成一个需要传入 DOM 节点的第三方库。​</p><p>操作步骤如下：​</p><ul><li>使用 useRef 创建一个 ref 对象。​</li><li>通过 JSX 的 ref 属性，将这个 ref 对象附加到目标 DOM 元素上。​</li><li>当组件渲染完成后，ref 对象的 .current 属性就会指向这个 DOM 节点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FocusInput</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 1. 创建一个 ref 来存放 input 元素​</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="comment">// 3. 在 effect 中访问 ref.current，确保 DOM 已挂载​</span></span><br><span class="line">    <span class="comment">// ?. 是可选链操作符，防止 inputRef.current 为 null 时报错​</span></span><br><span class="line">    inputRef.<span class="property">current</span>?.<span class="title function_">focus</span>(); ​</span><br><span class="line">  &#125;, []);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    <span class="comment">// 2. 将 ref 附加到 input 元素​</span></span><br><span class="line">    &lt;input ref=&#123;inputRef&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;I will be focused&quot;</span> /&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：应该在 <code>useEffect</code> 或事件处理函数中访问 <code>.current</code>，以确保 DOM 节点已经被创建并附加。</p><h5 id="存储任意可变值（实例变量）​"><a href="#存储任意可变值（实例变量）​" class="headerlink" title="存储任意可变值（实例变量）​"></a>存储任意可变值（实例变量）​</h5><p><code>useRef</code> 的 <code>.current</code> 属性就像是 Class 组件中的一个实例属性。它是一个“通用容器”，可以在组件的整个生命周期内持久保存任何值，且对它的修改不会触发重新渲染。​<br>这在需要存储定时器 ID、WebSocket 连接实例或任何与渲染无关的数据时非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">DebouncedSearch</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);​</span><br><span class="line">  <span class="comment">// 使用 ref 来存储定时器ID​</span></span><br><span class="line">  <span class="keyword">const</span> timeoutRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="comment">// 清除上一个定时器​</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutRef.<span class="property">current</span>);​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 设置一个新的定时器​</span></span><br><span class="line">    timeoutRef.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">      <span class="comment">// 这里的逻辑只会在用户停止输入500ms后执行​</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Searching for: <span class="subst">$&#123;query&#125;</span>`</span>);​</span><br><span class="line">    &#125;, <span class="number">500</span>);​</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 组件卸载时也清理一次​</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timeoutRef.<span class="property">current</span>);​</span><br><span class="line">  &#125;, [query]); <span class="comment">// 依赖于搜索词​</span></span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;query&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setQuery(e.target.value)&#125; /&gt;</span>;​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个防抖搜索的例子中，我们用 <code>useRef</code> 跨渲染周期地“记住”了定时器 ID，而无需在每次 ID 变化时都触发不必要的组件刷新。</p><h3 id="TypeScript-与-Hooks-的类型推断与显式声明"><a href="#TypeScript-与-Hooks-的类型推断与显式声明" class="headerlink" title="TypeScript 与 Hooks 的类型推断与显式声明"></a>TypeScript 与 Hooks 的类型推断与显式声明</h3><p>将 TypeScript 与 Hooks 结合使用，可以为我们的组件状态和副作用逻辑提供强大的类型安全保障。​</p><h4 id="useState-的类型​"><a href="#useState-的类型​" class="headerlink" title="useState 的类型​"></a>useState 的类型​</h4><p>在大多数情况下，TypeScript 能够根据传入 useState 的初始值推断出状态的类型，我们无需额外操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TS 推断出 count 是 number 类型​</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>); ​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// TS 推断出 name 是 string 类型​</span></span><br><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&#x27;React&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然而，当一个状态的初始值是 null，或者它可以是多种类型之一时，我们就需要显式地通过泛型来声明它的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">User</span> = &#123; <span class="attr">id</span>: string; <span class="attr">name</span>: string &#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 状态可以是 User 对象，或者在加载完成前是 null​</span></span><br><span class="line"><span class="keyword">const</span> [user, setUser] = useState&lt;<span class="title class_">User</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);​</span><br><span class="line">​</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">  <span class="title function_">fetchUserData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">fetchedUser</span> =&gt;</span> &#123;​</span><br><span class="line">    <span class="comment">// setUser 只能接受 User 类型或 null，否则 TS 会报错​</span></span><br><span class="line">    <span class="title function_">setUser</span>(fetchedUser); ​</span><br><span class="line">  &#125;);​</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h4 id="useRef-的类型​"><a href="#useRef-的类型​" class="headerlink" title="useRef 的类型​"></a>useRef 的类型​</h4><p>为 useRef 提供类型也遵循相似的逻辑。</p><ul><li>用于 DOM 元素时，我们需要指定它将附加到的 HTML 元素的具体类型，并将初始值设为 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref 将指向一个 HTMLInputElement 元素​</span></span><br><span class="line"><span class="keyword">const</span> inputRef = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>用于存储可变值时，我们只需在泛型中声明该值的类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ref 将用于存储一个数字类型的定时器 ID​</span><br><span class="line">const timerIdRef = useRef&lt;number | null&gt;(null);</span><br></pre></td></tr></table></figure><p>通过为 Hooks 提供准确的类型，我们不仅能在编码阶段捕捉到潜在的错误，还能让代码的意图更加清晰，可读性和可维护性都得到显著提升。</p><h1 id="进阶篇-探索-React-19-新范式"><a href="#进阶篇-探索-React-19-新范式" class="headerlink" title="进阶篇 - 探索 React 19 新范式"></a>进阶篇 - 探索 React 19 新范式</h1><h2 id="React-19-核心特性"><a href="#React-19-核心特性" class="headerlink" title="React 19 核心特性"></a>React 19 核心特性</h2><h4 id="Actions-表单交互的革命"><a href="#Actions-表单交互的革命" class="headerlink" title="Actions: 表单交互的革命"></a>Actions: 表单交互的革命</h4><p>长久以来，处理 Web 表单一直是一项繁琐的任务。开发者需要手动管理 loading 状态、错误信息、成功反馈，并用 <code>e.preventDefault()</code> 来阻止浏览器的默认行为。React 19 引入的 Actions 彻底颠覆了这一传统模式，将表单的异步交互与状态管理无缝集成到框架底层。​</p><p><strong>使用 <code>&lt;form&gt;</code> 的 <code>action</code> 属性简化数据提交​</strong><br>在 React 19 中，我们可以直接将一个函数（即 Action）传递给原生 <code>&lt;form&gt;</code> 元素的 action 属性。当你提交这个表单时，React 会自动拦截提交事件，处理表单数据的序列化（<code>FormData</code>），并调用你提供的 Action 函数。​<br>这意味着，我们可以告别 <code>onSubmit</code> 事件处理器和 <code>preventDefault()</code> 了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的表单处理方式​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">OldForm</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">e</span>) =&gt; &#123;​</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();​</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(e.<span class="property">target</span>);​</span><br><span class="line">    <span class="comment">// ...手动提交逻辑​</span></span><br><span class="line">  &#125;;​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// React 19 的新方式​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">NewForm</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 定义一个 Action 函数​</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submitAction</span> = <span class="keyword">async</span> (<span class="params">formData: FormData</span>) =&gt; &#123;​</span><br><span class="line">    <span class="keyword">const</span> name = formData.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>);​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Submitting name: <span class="subst">$&#123;name&#125;</span>`</span>);​</span><br><span class="line">    <span class="comment">// ...异步提交逻辑​</span></span><br><span class="line">    <span class="keyword">await</span> api.<span class="title function_">post</span>(<span class="string">&#x27;/users&#x27;</span>, &#123; name &#125;);​</span><br><span class="line">  &#125;;​</span><br><span class="line">  ​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;form action=&#123;submitAction&#125;&gt;​</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;​</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;<span class="title class_">Submit</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/form&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方式不仅代码更简洁，语义也更清晰：这个表单的“行为”（action）就是执行 <code>submitAction</code> 函数。​</p><p><strong>服务端 Actions 与客户端 Actions​</strong><br>Action 可以是定义在客户端的普通异步函数（客户端 Action），也可以是结合了“use server”指令、在服务端执行的函数（<strong>服务端 Action</strong>）。服务端 Actions 是 React Server Components 架构下的一个强大特性（通常在 Next.js 等全栈框架中使用），它允许前后端代码以前所未有的方式集成，实现无缝的 RPC 调用。在本课程中，我们将主要聚焦于客户端 Actions 的应用。​</p><p><strong>使用 <code>useActionState</code> 处理 <code>Pending/Error/Success</code> 状态​</strong><br>Actions 的真正威力在于它内置了对异步流程状态的管理能力。<code>useActionState</code> (在早期版本中被称为 <code>useFormState</code>) Hook 是专门为此设计的。它接收一个 Action 函数和初始状态，然后返回一个包含了当前状态、一个可被调用的新 Action 以及一个pending 状态的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useActionState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">AddToCartForm</span> = (<span class="params">&#123; productId &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 定义 Action，它接收前一个状态和 formData​</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addToCartAction</span> = <span class="keyword">async</span> (<span class="params">previousState, formData</span>) =&gt; &#123;​</span><br><span class="line">    <span class="keyword">const</span> quantity = formData.<span class="title function_">get</span>(<span class="string">&#x27;quantity&#x27;</span>);​</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">addToCartApi</span>(productId, quantity);​</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">success</span>) &#123;​</span><br><span class="line">      <span class="comment">// 返回新的成功状态​</span></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;Item added to cart!&#x27;</span> &#125;;​</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;​</span><br><span class="line">      <span class="comment">// 返回新的错误状态​</span></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">`Error: <span class="subst">$&#123;result.error&#125;</span>`</span> &#125;;​</span><br><span class="line">    &#125;​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 使用 useActionState​</span></span><br><span class="line">  <span class="keyword">const</span> [state, submitAction, isPending] = <span class="title function_">useActionState</span>(addToCartAction, <span class="literal">null</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;form action=&#123;submitAction&#125;&gt;​</span><br><span class="line">      &lt;input type=<span class="string">&quot;number&quot;</span> name=<span class="string">&quot;quantity&quot;</span> defaultValue=<span class="string">&quot;1&quot;</span> /&gt;​</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span> disabled=&#123;isPending&#125;&gt;​</span><br><span class="line">        &#123;isPending ? <span class="string">&#x27;Adding...&#x27;</span> : <span class="string">&#x27;Add to Cart&#x27;</span>&#125;​</span><br><span class="line">      &lt;/button&gt;​</span><br><span class="line">      &#123;state?.<span class="property">message</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;state.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;​</span><br><span class="line">    &lt;/form&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察上述代码，useActionState 极大地简化了状态管理。我们不再需要手动创建 <code>useState</code> 来管理 <code>isLoading</code>, <code>error</code>, <code>successMessage</code>。React 已经为我们处理好了一切：​</p><ul><li>当表单提交时，<code>isPending</code> 自动变为 true。​</li><li>Action 函数执行完毕后，<code>isPending</code> 自动变回 false。​</li><li>Action 函数的返回值会成为 <code>state</code> 的新值，从而触发 UI 更新。​</li></ul><p><strong>使用 <code>useFormStatus</code> 优化用户体验​</strong><br><code>useActionState</code> 管理的是整个表单的状态，但有时我们希望表单内的某个子组件（比如提交按钮）能够独立地响应表单的提交状态，而无需通过 props 逐层传递 isPending。<code>useFormStatus</code> Hook 正是为了解决这个问题而生。​<br>它只能在 <code>&lt;form&gt;</code> 组件的子组件中使用，并且会返回其所在表-单的当前状态信息，包括 <code>pending</code>, <code>data</code>, <code>method</code> 等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useFormStatus &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 一个独立的、能感知表单状态的按钮组件​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SubmitButton</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// useFormStatus 获取父级 &lt;form&gt; 的状态​</span></span><br><span class="line">  <span class="keyword">const</span> &#123; pending &#125; = <span class="title function_">useFormStatus</span>(); ​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;button type=<span class="string">&quot;submit&quot;</span> disabled=&#123;pending&#125;&gt;​</span><br><span class="line">      &#123;pending ? <span class="string">&#x27;Submitting...&#x27;</span> : <span class="string">&#x27;Submit&#x27;</span>&#125;​</span><br><span class="line">    &lt;/button&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 在表单中使用​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyForm</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submitAction</span> = <span class="keyword">async</span> (<span class="params">formData</span>) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;form action=&#123;submitAction&#125;&gt;​</span><br><span class="line">      &lt;input name=<span class="string">&quot;field&quot;</span> /&gt;​</span><br><span class="line">      &lt;<span class="title class_">SubmitButton</span> /&gt; ​</span><br><span class="line">    &lt;/form&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>useFormStatus</code>，我们创建了一个高度解耦且可复用的 <code>SubmitButton</code> 组件。它能自动响应任何包裹它的 <code>&lt;form&gt;</code> 的提交状态，代码组织更加清晰。</p><h3 id="并发与-use-Hook"><a href="#并发与-use-Hook" class="headerlink" title="并发与 use Hook"></a>并发与 use Hook</h3><p>并发（Concurrency）是 React 近年来最重要的底层升级，它允许 React 在渲染过程中处理多个状态更新，并根据优先级中断和恢复渲染任务。在 React 19 中，并发特性通过一个全新的、极其强大的 use Hook 得到了更直观的体现。​</p><p><strong>use Hook：在渲染中读取 Promise 和 Context​</strong><br>use Hook 是一个可以在渲染期间“解包”数据源的 Hook。目前它支持两种数据源：Promise 和 Context。​<br>与其他的 Hooks 不同，use 可以在条件语句、循环或普通函数中调用，这赋予了它前所未有的灵活性。​<br>当 use 被用于一个 Promise 时，它会做一件神奇的事情：​</p><ul><li>如果 Promise 正在 pending，它会“抛出”这个 Promise。​</li><li>这个“抛出”的行为会被最近的 <code>&lt;Suspense&gt;</code> 边界捕获，并显示 fallback UI。​</li><li>当 Promise <code>resolve</code> 后，React 会重新尝试渲染该组件，此时 use Hook 会返回 Promise 的结果值。​</li><li>如果 Promise <code>reject</code>，错误则会被最近的 <code>&lt;ErrorBoundary&gt;</code> 捕获。​</li></ul><p><strong>结合 Suspense 实现优雅的数据加载 UI​</strong><br>use 和 <code>&lt;Suspense&gt;</code> 的结合，是 React 官方推荐的、用于在客户端获取数据的方式，它彻底改变了“<code>Fetch-on-render</code>”的模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span>, use &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ErrorBoundary</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-error-boundary&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 一个获取数据的函数，它返回一个 Promise​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchMessage</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;Hello from the future!&quot;</span>), <span class="number">2000</span>));​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Message 组件在渲染时“读取”Promise​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Message</span> = (<span class="params">&#123; messagePromise &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 在渲染期间直接 use(promise)​</span></span><br><span class="line">  <span class="keyword">const</span> message = <span class="title function_">use</span>(messagePromise);​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message: &#123;message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// App 组件管理 Promise 的创建和 Suspense 边界​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 在渲染开始前就创建 Promise​</span></span><br><span class="line">  <span class="keyword">const</span> messagePromise = <span class="title function_">fetchMessage</span>();​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;h1&gt;<span class="title class_">My</span> <span class="title class_">App</span>&lt;/h1&gt;​</span><br><span class="line">      &lt;<span class="title class_">ErrorBoundary</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Oops, something went wrong.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;&gt;​</span><br><span class="line">        &lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>⏳ Loading message...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;&gt;​</span><br><span class="line">          &lt;<span class="title class_">Message</span> messagePromise=&#123;messagePromise&#125; /&gt;​</span><br><span class="line">        &lt;/<span class="title class_">Suspense</span>&gt;​</span><br><span class="line">      &lt;/<span class="title class_">ErrorBoundary</span>&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种模式被称为“<strong>Render-as-you-fetch</strong>”。我们不再需要在 useEffect 中获取数据，也无需手动管理 loading 状态。数据获取的请求在渲染开始时就已发出，组件则声明式地等待数据就位。这避免了网络请求的瀑布流问题，并使得数据加载的 UI 逻辑变得异常简洁和健壮。</p><h3 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h3><p>除了 Actions 和 <code>use</code> Hook，React 19 还带来了一系列旨在提升开发体验和应用性能的新功能。​<br>​<br><strong><code>useOptimistic</code>：实现乐观更新，提升交互体验​</strong><br>在与服务器交互时，为了让应用感觉更“快”，我们常常使用乐观更新（Optimistic Updates）技术。即在操作的请求还未得到服务器确认时，就先假设它会成功，并立即更新 UI。​<br><code>useOptimistic</code> Hook 将这种复杂的模式变得非常简单。它接收一个当前状态，并返回一个该状态的“乐观”副本以及一个更新函数。在异步操作期间，你可以调用更新函数来设置一个临时的、乐观的状态值。当异步操作结束后，无论是成功还是失败，React 都会自动将 UI 回滚到原始的、与服务器一致的状态。​<br>​<br><strong><code>Asset Loading</code>：通过 Suspense 管理资源加载​</strong><br>在过去，我们常常会遇到样式闪烁（FOUC）或因字体未加载完成而导致的布局抖动。React 19 将样式、字体、脚本等资源的加载也整合进了 Suspense 机制。​<br>现在，React 能够自动检测到组件渲染所依赖的样式表或字体，并在这些资源加载完成之前，暂停渲染并显示 <code>&lt;Suspense&gt;</code> 的 fallback UI。这从根本上保证了用户看到的永远是内容与样式完全匹配的、完整的界面，极大地提升了用户体验的稳定性。​<br>​<br><strong><code>ref</code> 作为 Prop：简化 <code>forwardRef</code>​</strong><br>forwardRef 是 React 中用于将 ref 从父组件转发到子组件内部 DOM 节点的 API，但它的写法相对冗长和不直观。在 React 19 中，这个过程被大大简化了。现在，ref 可以像普通 prop 一样直接传递给函数式组件，无需再用 <code>forwardRef</code> 进行包装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧方式​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyInputOld</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;​</span><br><span class="line">&#125;);​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// React 19 新方式​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyInputNew</span> = (<span class="params">props</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// &#x27;ref&#x27; is now a regular prop​</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;props.ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用时​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>();​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MyInputNew</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>; <span class="comment">// 直接传递 ref​</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-Compiler-理念篇"><a href="#React-Compiler-理念篇" class="headerlink" title="React Compiler (理念篇)"></a>React Compiler (理念篇)</h2><p>在 React 的世界里，性能优化一直是一个重要课题。当应用变得复杂，组件树层级加深时，不必要的重新渲染会成为性能瓶颈。为了解决这个问题，React 提供了 <code>React.memo</code>, <code>useMemo</code> 和 <code>useCallback</code> 等一系列手动优化的工具。然而，这些工具在带来性能提升的同时，也引入了新的复杂性。React Compiler 的诞生，正是为了将开发者从这种手动优化的困境中解放出来。</p><h3 id="手动优化的痛点：useMemo-useCallback-的困境"><a href="#手动优化的痛点：useMemo-useCallback-的困境" class="headerlink" title="手动优化的痛点：useMemo, useCallback 的困境"></a>手动优化的痛点：useMemo, useCallback 的困境</h3><p>让我们先回顾一下为何需要手动优化。在 React 中，当一个父组件的状态或 Props 发生变化时，它会默认重新渲染其所有的子组件，即使传递给某些子组件的 Props 并未发生任何改变。为了避免这种浪费，我们可以使用 <code>React.memo</code> 来包裹子组件，使其只有在 Props 真正发生变化时才重新渲染。​<br>这听起来很美好，但问题随之而来。如果父组件传递给子组件的 Props 是一个对象、数组或函数，那么在每次父组件渲染时，它们都会被重新创建，导致引用地址发生变化。从 <code>React.memo</code> 的角度看，这等同于 <code>Props</code> 发生了变化，从而导致优化失效。​<br>为了解决这个问题，我们被迫引入了 <code>useMemo</code> 来缓存对象或复杂计算的结果，以及 <code>useCallback</code> 来缓存函数实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个需要手动优化的场景​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ParentComponent</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);​</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 如果不使用 useMemo，每次 ParentComponent 渲染，user 对象都会被重建​</span></span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123;​</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,​</span><br><span class="line">    <span class="attr">count</span>: count,​</span><br><span class="line">  &#125;), [count]); <span class="comment">// 只有 count 变化时才重新创建 user 对象​</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 如果不使用 useCallback，每次 ParentComponent 渲染，handleClick 函数都会被重建​</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked, count is:&#x27;</span>, count);​</span><br><span class="line">  &#125;, [count]); <span class="comment">// 只有 count 变化时才重新创建 handleClick 函数​</span></span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;input value=&#123;text&#125; onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">setText</span>(e.<span class="property">target</span>.<span class="property">value</span>)&#125; /&gt;​</span><br><span class="line">      &#123;<span class="comment">/* MemoizedChild 只有在 user 或 handleClick 变化时才重新渲染 */</span>&#125;​</span><br><span class="line">      &lt;<span class="title class_">MemoizedChild</span> user=&#123;user&#125; onClick=&#123;handleClick&#125; /&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种手动优化的模式带来了诸多痛点：​</p><ul><li><strong>代码污染与心智负担</strong>：<code>useMemo</code> 和 <code>useCallback</code> 的大量使用，让组件的业务逻辑变得不再纯粹，代码可读性下降。开发者必须时刻思考“这里是否需要缓存？”，“那个函数是否需要用 <code>useCallback</code> 包裹？”。​</li><li><strong>依赖项数组的陷阱</strong>：管理依赖项数组是极其繁琐且容易出错的。忘记添加依赖项会导致“陈旧闭包”的 bug；添加了不必要的依赖项则可能导致缓存频繁失效，失去优化的意义。​</li><li><strong>偏离声明式初心</strong>：React 的核心魅力在于其声明式编程。我们本应只关心“UI 该是什么样”，但手动优化却迫使我们不断地向 React 发出命令式的指令：“请记住这个值”，“请不要重新创建这个函数”，这在一定程度上违背了 React 的设计哲学。</li></ul><h3 id="React-Compiler-“Forget”-的设计哲学与目标"><a href="#React-Compiler-“Forget”-的设计哲学与目标" class="headerlink" title="React Compiler (“Forget”) 的设计哲学与目标"></a>React Compiler (“Forget”) 的设计哲学与目标</h3><p>面对手动优化的种种困境，React 团队提出了一个釜底抽薪的解决方案：一个名为 React Compiler 的先进编译器，其内部代号为 “Forget”。​<br>“Forget” 这个名字精准地传达了它的设计哲学：<strong>它的目标是让开发者可以“忘记”手动性能优化这件事</strong>。​</p><p>React Compiler 的核心理念是，<strong>React 本就应该是默认具备高性能反应能力的（Reactive by default）</strong>。开发者应该能够编写最直白、最简洁的 JavaScript 和 React 代码，而由工具链来自动处理那些复杂的性能优化工作。它旨在将 React 从一个需要开发者手动提示才能实现最优性能的库，转变为一个足够智能、能够自动进行精细化优化的框架。​</p><p>其主要目标包括：​</p><ul><li>自动化记忆化（Memoization）：自动分析代码，并智能地包裹那些可以在多次渲染间复用的值、计算和组件，等效于自动插入 <code>useMemo</code>, <code>useCallback</code> 和 <code>React.memo</code>。​</li><li>提升开发者体验：将开发者从管理依赖项的苦差事中解放出来，让代码回归业务逻辑本身，使其更易于编写、阅读和维护。​</li><li>保持 JavaScript 语意：编译器在进行优化时，会严格遵守 JavaScript 的语言规则，确保编译后的代码行为与源代码完全一致。</li></ul><h3 id="Compiler-如何实现自动记忆化-Memoization"><a href="#Compiler-如何实现自动记忆化-Memoization" class="headerlink" title="Compiler 如何实现自动记忆化 (Memoization)"></a>Compiler 如何实现自动记忆化 (Memoization)</h3><p>React Compiler 并非 React 运行时库的一部分，而是一个编译时工具（通常作为 Babel 插件）。它在项目构建打包的过程中，对源代码进行深度分析和重写。​</p><p>它的工作原理（在一个较高的层次上）可以这样理解：​</p><ul><li>深度静态分析：编译器会像一个经验丰富的 React 开发者一样“阅读”你的组件代码。但它比任何人都更严谨、更不知疲倦。它能够理解 React 的规则（比如 props 和 state 的不可变性），也能够理解 JavaScript 的语义。​</li><li>建模与依赖追踪：它会构建出组件内所有值、对象、函数之间的依赖关系图。它能精确地知道，当某个 state 或 prop 变化时，到底会影响到哪些下游的计算和值。​</li><li>智能代码重写：基于分析结果，编译器会识别出那些计算成本较高或作为 props 传递且在多次渲染中可能保持不变的部分。然后，它会自动地、安全地将这些部分用缓存机制（类似于 <code>useMemo</code>）包裹起来。由于它拥有全局的依赖视图，它生成的“依赖项数组”远比手动维护的要精确。​<br>本质上，React Compiler 将性能优化的职责从开发者转移到了工具链。它通过在编译时进行一次性的、深入的分析，来换取运行时的高效以及开发时的简洁。</li></ul><h3 id="对现有代码库的影响与迁移策略"><a href="#对现有代码库的影响与迁移策略" class="headerlink" title="对现有代码库的影响与迁移策略"></a>对现有代码库的影响与迁移策略</h3><p>对于这样一个颠覆性的工具，开发者最关心的莫过于它对现有项目的影响。React Compiler 在设计上充分考虑了兼容性和渐进式采用。​</p><p><strong>对现有代码的影响​</strong></p><ul><li>向后兼容：React Compiler 被设计为完全向后兼容的。它足够智能，能够理解并尊重代码中已有的 <code>useMemo</code> 和 <code>useCallback</code> 。你现有的代码库在启用编译器后，行为不会发生改变。​</li><li>可选加入（Opt-in）：它不是一个强制性的功能。你可以选择是否在你的项目中启用它，甚至可以配置为只对项目的特定部分生效。​</li></ul><p><strong>迁移策略​</strong><br>迁移到由 React Compiler 驱动的开发模式是一个平滑且渐进的过程：​</p><ul><li>逐步启用：对于现有的大型项目，可以先在一些非核心或新增的功能模块中启用编译器，验证其效果和稳定性。​</li><li>移除冗余优化：在确认编译器工作正常后，可以开始逐步地、有信心地移除代码中手写的 <code>useMemo</code> 和 <code>useCallback</code>。这个过程可以让代码库变得越来越整洁。​</li><li>遵循编译器友好的代码模式：虽然编译器足够强大，但编写清晰、符合 React 最佳实践（如保持数据不可变性）的代码，将有助于编译器做出更有效的优化。​</li></ul><p>长远来看，React Compiler 的目标是让 <code>useMemo</code> 和 <code>useCallback</code> 成为只有在极少数、编译器无法自动处理的边缘场景下才需要动用的“专家级”工具。对于绝大多数日常开发而言，我们将可以彻底“忘记”它们的存在。</p><h2 id="高级-Hooks-与状态管理"><a href="#高级-Hooks-与状态管理" class="headerlink" title="高级 Hooks 与状态管理"></a>高级 Hooks 与状态管理</h2><p>随着应用功能的日益复杂，简单的 <code>useState</code> 已经不足以应对所有的状态管理需求。组件之间的数据共享、复杂状态的逻辑流转、以及伴随而来的性能问题，都对我们提出了更高的要求。本章将深入探讨 React 提供的更高级的状态管理工具，以及如何封装和复用我们的状态逻辑。</p><h3 id="复杂状态逻辑：useReducer-vs-useState​"><a href="#复杂状态逻辑：useReducer-vs-useState​" class="headerlink" title="复杂状态逻辑：useReducer vs useState​"></a>复杂状态逻辑：<code>useReducer</code> vs <code>useState</code>​</h3><p>我们已经熟练掌握了 useState，它非常适合处理简单的、独立的状态，如布尔值、字符串或数字。但当一个状态对象包含多个关联的字段，或者状态的下一个值依赖于前一个值的复杂计算时，<code>useState</code> 的更新逻辑就会散落在各个事件处理函数中，变得难以维护。​<br>为了应对这种场景，React 提供了另一个内置的 Hook：<code>useReducer</code>。它借鉴了 <code>Redux</code> 的思想，是一种将状态更新逻辑从组件中分离出来并集中管理的模式。​</p><p><code>useReducer</code> 接收一个 <code>reducer</code> 函数 和一个初始状态，返回当前的状态和一个 <code>dispatch</code> 函数。​</p><ul><li>Reducer 函数: 这是一个纯函数，它接收当前的状态（<code>state</code>）和一个动作（<code>action</code>）对象作为参数，然后返回一个全新的状态。所有状态如何变化的逻辑都定义在这里。​</li><li>Action 对象: 这是一个普通的 JavaScript 对象，通常包含一个 <code>type</code> 字段来描述操作类型，以及一个可选的 payload 字段来传递数据。​</li><li>Dispatch 函数: 我们在事件处理函数中调用 <code>dispatch(action)</code> 来“派发”一个动作。这会触发 React 调用我们的 <code>reducer</code> 函数，用它返回的新状态来更新 UI。​</li></ul><p>让我们用一个经典的购物车计数器例子来对比两者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 useReducer 来管理更复杂的 state​</span></span><br><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 1. 定义 state 的类型和初始 state​</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">lastAction</span>: <span class="literal">null</span> &#125;;​</span><br><span class="line">type <span class="title class_">State</span> = <span class="keyword">typeof</span> initialState;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 2. 定义 action 的类型​</span></span><br><span class="line">type <span class="title class_">Action</span> = &#123; <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>; <span class="attr">payload</span>: number &#125; | &#123; <span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>; <span class="attr">payload</span>: number &#125; | &#123; <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span> &#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 3. 编写 reducer 函数，集中处理所有状态转换逻辑​</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state: State, action: Action</span>): <span class="title class_">State</span> &#123;​</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;​</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:​</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + action.<span class="property">payload</span>, <span class="attr">lastAction</span>: <span class="string">&#x27;increment&#x27;</span> &#125;;​</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:​</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - action.<span class="property">payload</span>, <span class="attr">lastAction</span>: <span class="string">&#x27;decrement&#x27;</span> &#125;;​</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:​</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span>, <span class="attr">lastAction</span>: <span class="string">&#x27;reset&#x27;</span> &#125;;​</span><br><span class="line">    <span class="attr">default</span>:​</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 4. 在组件中使用 useReducer​</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;&gt;​</span><br><span class="line">      &lt;p&gt;<span class="title class_">Count</span>: &#123;state.<span class="property">count</span>&#125; (<span class="title class_">Last</span> <span class="attr">action</span>: &#123;state.<span class="property">lastAction</span>&#125;)&lt;/p&gt;​</span><br><span class="line">      &#123;<span class="comment">/* 5. 通过 dispatch 派发 action 来触发状态更新 */</span>&#125;​</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;)&#125;&gt;+<span class="number">1</span>&lt;/button&gt;​</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;)&#125;&gt;-<span class="number">1</span>&lt;/button&gt;​</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span> &#125;)&#125;&gt;<span class="title class_">Reset</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>何时选择 useReducer？​</strong></p><ul><li>当状态逻辑非常复杂，涉及多个子值时。​</li><li>当下一个状态严重依赖于前一个状态时。​</li><li>当你想将状态变更的逻辑提取出组件，以便于独立测试和维护时。​</li><li>在多人协作的大型项目中，useReducer 提供了更可预测和严格的状态流。​</li></ul><p>对于简单场景，useState 依然是更简洁的选择。</p><h3 id="全局状态管理：useContext-与性能陷阱"><a href="#全局状态管理：useContext-与性能陷阱" class="headerlink" title="全局状态管理：useContext 与性能陷阱"></a>全局状态管理：useContext 与性能陷阱</h3><p>当多个散落在组件树不同位置的组件需要共享同一个状态时（例如，当前登录的用户信息、全局的主题设置），逐层通过 props 传递数据会变得非常繁琐和低效，这种现象被称为“<strong>Prop Drilling</strong>”（属性钻探）。​<br>为了解决这个问题，React 提供了 <strong>Context API</strong>。它允许我们创建一个全局的数据“广播站”，任何在这个“广播站”覆盖范围内的组件，都可以直接“收听”到这份数据，而无需关心它们在组件树中的层级深度。​</p><p>使用 Context 主要分为三步：​</p><ul><li><code>createContext</code>: 在应用的上层创建一个 Context 对象。​</li><li>Provider: 使用 <code>MyContext.Provider</code> 组件将需要共享的数据通过 <code>value</code> 属性“广播”出去。这个 Provider 会包裹住所有可能需要这份数据的子组件。​</li><li><code>useContext</code>: 在任何一个子组件中，通过 <code>useContext(MyContext)</code> Hook 来“订阅”并获取这份数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 ThemeContext​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title function_">createContext</span>(<span class="string">&#x27;light&#x27;</span>);​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// App.tsx​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = <span class="title function_">useState</span>(<span class="string">&#x27;light&#x27;</span>);​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    <span class="comment">// 2. 使用 Provider 提供当前的 theme 值​</span></span><br><span class="line">    &lt;<span class="title class_">ThemeContext</span>.<span class="property">Provider</span> value=&#123;theme&#125;&gt;​</span><br><span class="line">      &lt;<span class="title class_">Toolbar</span> /&gt;​</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="title function_">setTheme</span>(theme === <span class="string">&#x27;light&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>)&#125;&gt;​</span><br><span class="line">        <span class="title class_">Toggle</span> <span class="title class_">Theme</span>​</span><br><span class="line">      &lt;/button&gt;​</span><br><span class="line">    &lt;/<span class="title class_">ThemeContext</span>.<span class="property">Provider</span>&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Toolbar.tsx - 中间组件，无需关心 theme​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Toolbar</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// ThemedButton.tsx - 深度嵌套的子组件​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ThemedButton</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 3. 直接通过 useContext 获取 theme​</span></span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">theme</span> === <span class="string">&#x27;dark&#x27;</span> ? &#x27;#<span class="attr">333</span>&#x27; <span class="attr">:</span> &#x27;#<span class="attr">FFF</span>&#x27; &#125;&#125;&gt;</span>I am a themed button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>性能陷阱​</strong><br>Context 虽然强大，但它有一个重要的性能特征：当 Provider 的 <code>value</code> 发生变化时，所有消费该 Context 的组件（即调用了 <code>useContext</code> 的组件）都会被强制重新渲染。即使这些组件只关心 value 对象中的一小部分数据，只要 <code>value</code> 的引用地址发生变化，它们也会被波及。​<br>如果 value 是一个复杂的对象，并且在父组件的每次渲染中都被重新创建，这可能会导致不必要的性能开销。解决方案通常是结合 <code>useMemo</code> 来缓存 <code>value</code> 对象，或者将一个大的 Context 拆分成多个更细粒度的 Context。</p><h3 id="手动性能优化：React-memo-useMemo-useCallback-的正确使用场景"><a href="#手动性能优化：React-memo-useMemo-useCallback-的正确使用场景" class="headerlink" title="手动性能优化：React.memo, useMemo, useCallback 的正确使用场景"></a>手动性能优化：React.memo, useMemo, useCallback 的正确使用场景</h3><p>正如第五章所述，React Compiler 的目标是自动化性能优化。但在它完全成熟和普及之前，或者在某些需要精细调优的场景下，理解手动优化的工具仍然是一项必备技能。​</p><ul><li><code>React.memo</code>: 这是一个高阶组件，用于包裹你的函数式组件。它会对传入的 props 进行浅比较，只有在 props 发生变化时，才会重新渲染被包裹的组件。这是防止因父组件渲染而导致的不必要子组件渲染的主要工具。​</li><li><code>useMemo</code>: 这个 Hook 用于“记忆化”一个计算结果。它接收一个函数和一个依赖项数组，只有在依赖项发生变化时，才会重新执行该函数并返回新的值。它主要用于两个场景：​<ul><li>缓存开销巨大的计算结果，避免在每次渲染时都重复计算。​</li><li>当向一个被 <code>React.memo</code> 包裹的子组件传递对象或数组作为 prop 时，使用 <code>useMemo</code> 来保证该 prop 的引用稳定性。​</li></ul></li><li><code>useCallback</code>: 这个 Hook 用于“记忆化”一个函数实例。它与 <code>useMemo</code> 类似，但专门用于函数。主要使用场景是：当向一个被 <code>React.memo</code> 包裹的子组件传递函数作为 <code>prop</code> 时，使用 <code>useCallback</code> 来保证该函数 prop 的引用稳定性。<blockquote><p>核心原则：不要过早优化。这些 API 自身也有成本（内存占用和比较开销）。只在你通过 React DevTools Profiler 等工具确认了某个组件存在性能瓶颈时，才应该考虑使用它们进行优化</p></blockquote></li></ul><h3 id="自定义-Hooks：封装逻辑与实现复用-含-TS-泛型"><a href="#自定义-Hooks：封装逻辑与实现复用-含-TS-泛型" class="headerlink" title="自定义 Hooks：封装逻辑与实现复用 (含 TS 泛型)"></a>自定义 Hooks：封装逻辑与实现复用 (含 TS 泛型)</h3><p>自定义 Hook 是现代 React 中实现逻辑复用的基石。它是一个以 use 开头的 JavaScript 函数，其内部可以调用其他的 Hooks（如 <code>useState</code>, <code>useEffect</code> 等）。通过自定义 Hook，我们可以将组件中可复用的状态逻辑（而非 UI）提取出来，让组件本身保持简洁，只关注于渲染。​<br>假设我们有多个组件都需要从本地存储（LocalStorage）中读取和写入数据，我们可以创建一个 <code>useLocalStorageState</code> 的自定义 Hook。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 自定义 Hook - 使用了 TypeScript 泛型 &lt;T&gt;​</span></span><br><span class="line"><span class="keyword">function</span> useLocalStorageState&lt;T&gt;(<span class="attr">key</span>: string, <span class="attr">defaultValue</span>: T): [T, <span class="title class_">React</span>.<span class="property">Dispatch</span>&lt;<span class="title class_">React</span>.<span class="property">SetStateAction</span>&lt;T&gt;&gt;] &#123;​</span><br><span class="line">  <span class="comment">// 1. 从 localStorage 读取初始值​</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState&lt;T&gt;(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="keyword">const</span> storedValue = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key);​</span><br><span class="line">    <span class="keyword">return</span> storedValue !== <span class="literal">null</span> ? <span class="title class_">JSON</span>.<span class="title function_">parse</span>(storedValue) : defaultValue;​</span><br><span class="line">  &#125;);​</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 2. 每当 state 变化时，将其写入 localStorage​</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));​</span><br><span class="line">  &#125;, [key, state]);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> [state, setState];​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 在组件中使用自定义 Hook​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserSettings</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useLocalStorageState&lt;<span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>&gt;(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>);​</span><br><span class="line">  <span class="keyword">const</span> [fontSize, setFontSize] = useLocalStorageState&lt;number&gt;(<span class="string">&#x27;fontSize&#x27;</span>, <span class="number">16</span>);​</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// ... UI to change theme and font size​</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 TypeScript 的<strong>泛型 T</strong>。这使得我们的 <code>useLocalStorageState</code> Hook 可以适用于任何可被 JSON 序列化的数据类型，无论是字符串、数字还是对象，同时保持了完整的类型安全。这就是自定义 Hook 结合 TypeScript 的强大之处：创建高度可复用、类型安全且与 UI 无关的逻辑单元。</p><h2 id="TypeScript-高级应用"><a href="#TypeScript-高级应用" class="headerlink" title="TypeScript 高级应用"></a>TypeScript 高级应用</h2><p>在前面的章节中，我们已经将 TypeScript 应用于 Props 和 Hooks，奠定了类型安全的基础。本章我们将更进一步，探索 TypeScript 在 React 开发中的一些高级用法，学习如何利用泛型和类型工具来构建更加灵活、健壮且易于维护的组件和 Hooks。</p><h3 id="泛型组件与泛型-Hooks"><a href="#泛型组件与泛型-Hooks" class="headerlink" title="泛型组件与泛型 Hooks"></a>泛型组件与泛型 Hooks</h3><p>我们已经在自定义 Hook 中见识了泛型的威力，同样的能力也可以被应用在泛型组件上。泛型组件允许我们在定义组件时不预先写死其处理的数据类型，而是由使用该组件的父组件来指定。​<br>这在创建可复用的列表、表格、下拉菜单等 UI 模式时非常有用。例如，我们可以创建一个可以渲染任何类型数据数组的 <code>List</code> 组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 定义泛型 Props 类型​</span></span><br><span class="line"><span class="comment">// &lt;T&gt; 是一个类型变量，在使用组件时会被具体类型替换​</span></span><br><span class="line">type <span class="title class_">ListProps</span>&lt;T&gt; = &#123;​</span><br><span class="line">  <span class="attr">items</span>: T[]; <span class="comment">// items 是一个 T 类型的数组​</span></span><br><span class="line">  <span class="attr">renderItem</span>: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="title class_">React</span>.<span class="property">ReactNode</span>; <span class="comment">// renderItem 函数接收一个 T 类型的参数​</span></span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 定义泛型组件 List&lt;T&gt;​</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title class_">List</span>&lt;T&gt;(&#123; items, renderItem &#125;: <span class="title class_">ListProps</span>&lt;T&gt;) &#123;​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;ul&gt;​</span><br><span class="line">      &#123;items.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (​</span><br><span class="line">        <span class="comment">// 这里 item 的类型被正确推断为 T​</span></span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;<span class="title function_">renderItem</span>(item)&#125;&lt;/li&gt;​</span><br><span class="line">      ))&#125;​</span><br><span class="line">    &lt;/ul&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用泛型组件​</span></span><br><span class="line">type <span class="title class_">User</span> = &#123; <span class="attr">id</span>: number; <span class="attr">name</span>: string &#125;;​</span><br><span class="line"><span class="keyword">const</span> <span class="attr">users</span>: <span class="title class_">User</span>[] = [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;];​</span><br><span class="line">​</span><br><span class="line">type <span class="title class_">Product</span> = &#123; <span class="attr">sku</span>: string; <span class="attr">price</span>: number &#125;;​</span><br><span class="line"><span class="keyword">const</span> <span class="attr">products</span>: <span class="title class_">Product</span>[] = [&#123; <span class="attr">sku</span>: <span class="string">&#x27;X123&#x27;</span>, <span class="attr">price</span>: <span class="number">99.9</span> &#125;];​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (​</span><br><span class="line">  &lt;&gt;​</span><br><span class="line">    &#123;<span class="comment">/* 此时，T 被指定为 User */</span>&#125;​</span><br><span class="line">    &lt;<span class="title class_">List</span>&lt;<span class="title class_">User</span>&gt;​</span><br><span class="line">      items=&#123;users&#125;​</span><br><span class="line">      renderItem=&#123;<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;​</span><br><span class="line">    /&gt;​</span><br><span class="line">    &#123;<span class="comment">/* 此时，T 被指定为 Product */</span>&#125;​</span><br><span class="line">    &lt;<span class="title class_">List</span>&lt;<span class="title class_">Product</span>&gt;​</span><br><span class="line">      items=&#123;products&#125;​</span><br><span class="line">      renderItem=&#123;<span class="function">(<span class="params">product</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;product.sku&#125;: $&#123;product.price&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;​</span><br><span class="line">    /&gt;​</span><br><span class="line">  &lt;/&gt;​</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过泛型，我们创建了一个高度抽象且完全类型安全的 <code>List</code> 组件，它将“渲染什么”的逻辑（<code>renderItem</code>）交给了调用者，而自己只负责“如何渲染”（列表结构）的逻辑。</p><h3 id="React-事件对象的精确类型"><a href="#React-事件对象的精确类型" class="headerlink" title="React 事件对象的精确类型"></a>React 事件对象的精确类型</h3><p>在事件处理函数中，为事件对象 e 提供精确的类型，可以帮助我们安全地访问特定于该事件的属性（如 <code>e.target.value</code>），并获得编辑器的智能提示。<code>@types/react</code> 包为我们预定义了丰富的事件类型。​<br>放弃使用宽泛的 <code>any</code> 或 <code>React.SyntheticEvent</code>，转而使用更具体的类型是一个好习惯：​</p><ul><li><strong>鼠标事件</strong>: <code>React.MouseEvent&lt;HTMLElement&gt;</code>​</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params">e: React.MouseEvent&lt;HTMLButtonElement&gt;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// e.currentTarget 的类型是 HTMLButtonElement​</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">currentTarget</span>.<span class="property">tagName</span>); <span class="comment">// &quot;BUTTON&quot;​</span></span><br><span class="line">&#125;;​</span><br></pre></td></tr></table></figure><ul><li><strong>表单元素变化事件</strong>: <code>React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement&gt;​</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// e.target.value 的类型被正确推断为 string​</span></span><br><span class="line">  <span class="title function_">setValue</span>(e.<span class="property">target</span>.<span class="property">value</span>);​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>表单提交事件</strong>: <code>React.FormEvent&lt;HTMLFormElement&gt;</code>​</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123;​</span><br><span class="line">  e.preventDefault();​</span><br><span class="line">  // e.currentTarget 的类型是 HTMLFormElement​</span><br><span class="line">  console.log(&#x27;Form submitted&#x27;);​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用精确的事件类型，可以让我们的代码更加健壮，有效防止因访问不存在的属性而导致的运行时错误。</p><h3 id="结合-Zod-进行运行时类型校验"><a href="#结合-Zod-进行运行时类型校验" class="headerlink" title="结合 Zod 进行运行时类型校验"></a>结合 <strong>Zod</strong> 进行运行时类型校验</h3><p>TypeScript 的类型系统在编译时为我们提供了强大的保护，但这份保护在应用的“边界”处会失效——尤其是当我们从外部 API 接收数据时。API 返回的数据结构可能与我们预期的 TypeScript 类型不符，这可能导致运行时错误。​<br>为了弥补这一短板，我们引入运行时类型校验库，其中 <strong>Zod</strong> 是当前最流行和强大的选择。<strong>Zod</strong> 允许我们定义一个数据的 <code>schema</code>（模式），然后用它来解析（<code>parse</code>）未知来源的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">&#x27;zod&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 1. 使用 Zod 定义 User 的 schema​</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserSchema</span> = z.<span class="title function_">object</span>(&#123;​</span><br><span class="line">  <span class="attr">id</span>: z.<span class="title function_">string</span>(),​</span><br><span class="line">  <span class="attr">name</span>: z.<span class="title function_">string</span>(),​</span><br><span class="line">  <span class="attr">email</span>: z.<span class="title function_">string</span>().<span class="title function_">email</span>(),​</span><br><span class="line">  <span class="attr">isAdmin</span>: z.<span class="title function_">boolean</span>().<span class="title function_">optional</span>(),​</span><br><span class="line">&#125;);​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 2. 从 Zod schema 推断出 TypeScript 类型​</span></span><br><span class="line">type <span class="title class_">User</span> = z.<span class="property">infer</span>&lt;<span class="keyword">typeof</span> <span class="title class_">UserSchema</span>&gt;;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 在数据获取函数中使用​</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params">userId: string</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api/users/<span class="subst">$&#123;userId&#125;</span>`</span>);​</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">try</span> &#123;​</span><br><span class="line">    <span class="comment">// 3. 使用 schema.parse 来校验和解析数据​</span></span><br><span class="line">    <span class="comment">// 如果数据结构不符合 schema，这里会抛出一个详细的错误​</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="title class_">UserSchema</span>.<span class="title function_">parse</span>(data);​</span><br><span class="line">    <span class="keyword">return</span> user;​</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;API data validation failed:&#x27;</span>, error);​</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid user data received from server.&#x27;</span>);​</span><br><span class="line">  &#125;​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“TypeScript + Zod”是一个黄金组合。我们只需维护一份 Zod schema，就可以同时获得运行时的安全校验和编译时的静态类型提示（通过 <code>z.infer</code>），极大地提升了处理外部数据的健壮性。</p><h3 id="高级类型工具-Utility-Types-在组件-Props-中的应用"><a href="#高级类型工具-Utility-Types-在组件-Props-中的应用" class="headerlink" title="高级类型工具 (Utility Types) 在组件 Props 中的应用"></a>高级类型工具 (Utility Types) 在组件 Props 中的应用</h3><p>TypeScript 内置了一系列高级类型工具（<strong>Utility Types</strong>），它们就像是操作类型的函数，可以基于已有类型创建出新的、衍生出的类型。在定义复杂的组件 Props 时，它们非常有用，可以帮助我们避免重复定义，保持类型的一致性。​<br>一些在 React 中常用的高级类型工具包括：​</p><ul><li><code>Partial&lt;Type&gt;</code>: 将 Type 中的所有属性变为可选。​</li><li><code>Required&lt;Type&gt;</code>: 将 Type 中的所有属性变为必选。​</li><li><code>Pick&lt;Type, Keys&gt;</code>: 从 Type 中挑选出指定的 Keys 属性来创建一个新类型。​</li><li><code>Omit&lt;Type, Keys&gt;</code>: 从 Type 中排除掉指定的 Keys 属性来创建一个新类型。​<br>结合 React 自带的 <code>ComponentProps</code> 类型，我们可以实现非常灵活的 Props 定义。例如，创建一个自定义 <code>Button</code> 组件，它继承原生 <code>&lt;button&gt;</code> 的所有属性，但我们想自定义 <code>onClick</code> 的行为。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用 Omit 来排除原生的 onClick，因为我们要自定义它​</span></span><br><span class="line">type <span class="title class_">ButtonProps</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">React</span>.<span class="property">ComponentProps</span>&lt;<span class="string">&#x27;button&#x27;</span>&gt;, <span class="string">&#x27;onClick&#x27;</span>&gt; &amp; &#123;​</span><br><span class="line">  <span class="comment">// 自定义我们的 onClick prop​</span></span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">source: <span class="string">&#x27;custom-button&#x27;</span></span>) =&gt;</span> <span class="keyword">void</span>;​</span><br><span class="line">  <span class="attr">variant</span>: <span class="string">&#x27;primary&#x27;</span> | <span class="string">&#x27;secondary&#x27;</span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">CustomButton</span> = (<span class="params">&#123; onClick, variant, ...rest &#125;: ButtonProps</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">    <span class="title function_">onClick</span>(<span class="string">&#x27;custom-button&#x27;</span>);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;button​</span><br><span class="line">      onClick=&#123;handleClick&#125;​</span><br><span class="line">      <span class="comment">// 其他所有原生 button 属性都通过 ...rest 透传下去​</span></span><br><span class="line">      <span class="comment">// 例如 disabled, type, className 等​</span></span><br><span class="line">      &#123;...rest&#125; ​</span><br><span class="line">      style=&#123;&#123; <span class="attr">backgroundColor</span>: variant === <span class="string">&#x27;primary&#x27;</span> ? <span class="string">&#x27;blue&#x27;</span> : <span class="string">&#x27;gray&#x27;</span> &#125;&#125;​</span><br><span class="line">    /&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们创建的 CustomButton 组件既拥有了强类型的自定义 props (<code>variant</code>, <code>onClick</code>)，又继承了原生按钮的所有能力，同时保持了极高的灵活性和类型安全。</p><h1 id="实战篇-构建企业级项目"><a href="#实战篇-构建企业级项目" class="headerlink" title="实战篇 - 构建企业级项目"></a>实战篇 - 构建企业级项目</h1><p>理论是基石，实践是高塔。本部分将带领您亲手将蓝图变为现实。我们将模拟真实的企业开发流程，构建一个 Trello&#x2F;Jira 类的项目管理看板。我们将在这个过程中，熟练掌握现代化 React 项目的全生命周期，从最初的需求分析与技术选型，到核心功能的开发，再到最终的质量保障与自动化部署。</p><h2 id="项目启动与架构设计"><a href="#项目启动与架构设计" class="headerlink" title="项目启动与架构设计"></a>项目启动与架构设计</h2><h3 id="项目需求分析与技术选型"><a href="#项目需求分析与技术选型" class="headerlink" title="项目需求分析与技术选型"></a>项目需求分析与技术选型</h3><p>在编写第一行代码之前，我们必须明确我们要构建的是什么，以及我们将使用什么工具来构建。​</p><p><strong>项目需求分析 (Trello&#x2F;Jira 看板)​</strong><br>我们的目标是创建一个项目管理看板应用，其核心功能应包括：​</p><ul><li>用户认证：支持用户注册和登录。​</li><li>看板空间 (Workspace)：用户可以创建和加入多个看板空间。​</li><li>看板 (Board)：在空间内，可以创建多个看板，每个看板有自己的背景和设置。​</li><li>列表 (List)：每个看板由多个列表组成（如 “待办”、“进行中”、“已完成”）。​</li><li>卡片 (Card)：卡片是最小的工作单元，可以在列表之间拖拽。​</li><li>卡片详情：点击卡片可以打开模态框，查看和编辑卡片的详细信息（描述、附件、评论等）。​</li><li>拖拽功能：支持列表和卡片的拖拽排序。​</li></ul><p><strong>技术选型​</strong><br>基于我们的需求和之前学习的现代化技术，我们确定以下技术栈：​</p><ul><li>构建工具：Vite - 提供极致的开发体验。​</li><li>核心框架：React 19 + TypeScript - 享受最新的 React 特性与类型安全。​</li><li>路由管理：React Router v6+ - 强大的客户端路由解决方案。​</li><li>全局状态管理：Zustand - 轻量、简洁、对 TypeScript 支持良好。​</li><li>服务端状态管理：React Query (TanStack Query) - 优雅地处理数据获取、缓存和同步。​</li><li>UI 与样式：Tailwind CSS - 高效的 Utility-First CSS 框架。​</li><li>表单处理：React Hook Form + Zod - 兼顾性能与运行时校验。​</li><li>组件库：shadcn&#x2F;ui - 提供灵活、可定制、易于接入的 UI 组件。​</li><li>拖拽库：dnd-kit - 专为 React 设计的现代化、可访问性高的拖拽库。​</li></ul><h3 id="搭建项目结构与配置代码规范"><a href="#搭建项目结构与配置代码规范" class="headerlink" title="搭建项目结构与配置代码规范"></a>搭建项目结构与配置代码规范</h3><p>一个清晰、可预测的项目结构对于长期维护至关重要。我们将采用功能优先 (Feature-based) 的目录结构，将相关的文件（组件、Hooks、API 调用等）组织在一起。​</p><p><strong>项目目录结构示例</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/src​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/app</span>            <span class="comment"># 全局配置，如路由、Provider 等​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/assets</span>         <span class="comment"># 静态资源，如图片、字体​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/components</span>     <span class="comment"># 全局共享的通用组件​</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|--</span> <span class="string">/ui</span>         <span class="comment"># 通过 shadcn/ui 生成的 UI 组件 (Button, Input...)​</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|--</span> <span class="string">/shared</span>     <span class="comment"># 自定义的共享组件 (Header, Footer...)​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/features</span>       <span class="comment"># 核心功能模块​</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|--</span> <span class="string">/auth</span>       <span class="comment"># 认证相关​</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|--</span> <span class="string">/board</span>      <span class="comment"># 看板相关​</span></span><br><span class="line"><span class="string">|</span>       <span class="string">|--</span> <span class="string">/components​</span></span><br><span class="line"><span class="string">|</span>       <span class="string">|--</span> <span class="string">/hooks​</span></span><br><span class="line"><span class="string">|</span>       <span class="string">|--</span> <span class="string">/api​</span></span><br><span class="line"><span class="string">|</span>       <span class="string">|--</span> <span class="string">index.ts​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/hooks</span>          <span class="comment"># 全局共享的自定义 Hooks​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/lib</span>            <span class="comment"># 工具函数、常量等​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/store</span>          <span class="comment"># Zustand 的 store 定义​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">/types</span>          <span class="comment"># 全局 TypeScript 类型定义​</span></span><br><span class="line"><span class="string">|--</span> <span class="string">main.tsx</span>        <span class="comment"># 应用入口​</span></span><br></pre></td></tr></table></figure><p><strong>配置代码规范</strong></p><p>为了保证团队协作的顺畅和代码质量的一致性，我们需要配置代码规范工具：​</p><ul><li><strong>ESLint</strong>: 一个可配置的 JavaScript&#x2F;TypeScript 代码检查工具，用于发现并修复代码中的问题。​</li><li><strong>Prettier</strong>: 一个“有主见”的代码格式化工具，它会强制统一的代码风格。​</li><li><strong>Husky + lint-staged</strong>: 这两个工具组合可以在我们每次提交代码到 Git 仓库之前，自动运行 ESLint 和 Prettier，确保所有提交的代码都符合规范。​</li></ul><p>通过在 <code>package.json</code> 中配置脚本并安装相应的依赖，我们可以实现保存文件时自动格式化、提交代码前自动检查的开发流程。</p><h3 id="路由管理：React-Router-v6"><a href="#路由管理：React-Router-v6" class="headerlink" title="路由管理：React Router v6+"></a>路由管理：React Router v6+</h3><p>React Router 是 React 应用中路由管理的事实标准。在 v6.4 之后，它引入了全新的数据路由 API (<code>createBrowserRouter</code>)，这与 React 19 的 Actions 和 Suspense 等特性结合得更加紧密。​<br>我们将使用 <code>createBrowserRouter</code> 来定义应用的全部路由规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/router.tsx​</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;​</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppLayout</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./AppLayout&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([​</span><br><span class="line">  &#123;​</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,​</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">AppLayout</span> /&gt;</span></span>, <span class="comment">// 使用布局组件包裹多个页面​</span></span><br><span class="line">    <span class="attr">children</span>: [​</span><br><span class="line">      &#123;​</span><br><span class="line">        <span class="attr">index</span>: <span class="literal">true</span>, <span class="comment">// 默认首页​</span></span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>,​</span><br><span class="line">      &#125;,​</span><br><span class="line">      &#123;​</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;board/:boardId&#x27;</span>, <span class="comment">// 动态路由，:boardId 是一个参数​</span></span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">BoardPage</span> /&gt;</span></span>,​</span><br><span class="line">      &#125;,​</span><br><span class="line">    ],​</span><br><span class="line">  &#125;,​</span><br><span class="line">  &#123;​</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,​</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">LoginPage</span> /&gt;</span></span>,​</span><br><span class="line">  &#125;,​</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><strong>动态路由与嵌套路由</strong></p><ul><li>动态路由 (<code>path: &#39;board/:boardId&#39;</code>) 允许我们为同一类型的页面创建不同的 URL，例如 <code>/board/1</code> 和 <code>/board/2</code> 都会渲染 BoardPage 组件。在 BoardPage 组件中，我们可以通过 <code>useParams</code> Hook 来获取 <code>boardId</code> 的值。​</li><li>嵌套路由 (通过 <code>children</code> 属性) 非常适合实现共享的页面布局。在上面的例子中，所有 <code>/</code> 下的子页面都会被渲染在 <code>AppLayout</code> 组件内部的一个 <code>&lt;Outlet /&gt;</code> 占位符中，从而轻松实现共享的导航栏或侧边栏。​</li></ul><p><strong>懒加载 (Lazy Loading)​</strong><br>为了优化应用的初始加载性能，我们不应该一次性加载所有页面的代码。通过 <code>React.lazy</code> 和 <code>&lt;Suspense&gt;</code>，我们可以实现路由级别的代码分割。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BoardPage</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../features/board/BoardPage&#x27;</span>));​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// ... 在路由配置中​</span></span><br><span class="line">&#123;​</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;board/:boardId&#x27;</span>,​</span><br><span class="line">  <span class="attr">element</span>: (​</span><br><span class="line">    &lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading page...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&gt;​</span><br><span class="line">      &lt;<span class="title class_">BoardPage</span> /&gt;​</span><br><span class="line">    &lt;/<span class="title class_">Suspense</span>&gt;​</span><br><span class="line">  ),​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置后，只有当用户访问 <code>/board/...</code>路径时，浏览器才会去下载 <code>BoardPage</code> 组件及其相关的代码，从而显著减小了首屏加载的体积。</p><h2 id="核心功能开发"><a href="#核心功能开发" class="headerlink" title="核心功能开发"></a>核心功能开发</h2><h3 id="状态管理-Zustand-轻量、高效的全局状态管理方案"><a href="#状态管理-Zustand-轻量、高效的全局状态管理方案" class="headerlink" title="状态管理: Zustand - 轻量、高效的全局状态管理方案"></a>状态管理: Zustand - 轻量、高效的全局状态管理方案</h3><p><strong>Zustand</strong> 是一个极简但功能强大的全局状态管理库。它基于 Hooks，无需像 <code>Redux</code> 那样编写大量的模板代码，也无需用 Provider 包裹整个应用。​<br>我们将使用 <strong>Zustand</strong> 来管理那些需要在多个不相关组件间共享的客户端状态，例如 UI 的状态（侧边栏是否展开）或当前用户的认证信息。​</p><p>创建一个 <code>Store</code> 非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/authStore.ts​</span></span><br><span class="line"><span class="keyword">import</span> &#123; create &#125; <span class="keyword">from</span> <span class="string">&#x27;zustand&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line">type <span class="title class_">AuthState</span> = &#123;​</span><br><span class="line">  <span class="attr">user</span>: &#123; <span class="attr">id</span>: string; <span class="attr">name</span>: string &#125; | <span class="literal">null</span>;​</span><br><span class="line">  <span class="attr">token</span>: string | <span class="literal">null</span>;​</span><br><span class="line">  <span class="attr">setUser</span>: <span class="function">(<span class="params">user: AuthState[<span class="string">&#x27;user&#x27;</span>], token: string</span>) =&gt;</span> <span class="keyword">void</span>;​</span><br><span class="line">  <span class="attr">logout</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span>;​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useAuthStore = create&lt;<span class="title class_">AuthState</span>&gt;(<span class="function">(<span class="params">set</span>) =&gt;</span> (&#123;​</span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span>,​</span><br><span class="line">  <span class="attr">token</span>: <span class="literal">null</span>,​</span><br><span class="line">  <span class="attr">setUser</span>: <span class="function">(<span class="params">user, token</span>) =&gt;</span> <span class="title function_">set</span>(&#123; user, token &#125;),​</span><br><span class="line">  <span class="attr">logout</span>: <span class="function">() =&gt;</span> <span class="title function_">set</span>(&#123; <span class="attr">user</span>: <span class="literal">null</span>, <span class="attr">token</span>: <span class="literal">null</span> &#125;),​</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>在任何组件中，我们都可以像使用普通 Hook 一样来使用这个 Store：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAuthStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/authStore&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserProfile</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> &#123; user, logout &#125; = <span class="title function_">useAuthStore</span>();​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="keyword">return</span> <span class="literal">null</span>;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;span&gt;<span class="title class_">Welcome</span>, &#123;user.<span class="property">name</span>&#125;&lt;/span&gt;​</span><br><span class="line">      &lt;button onClick=&#123;logout&#125;&gt;<span class="title class_">Logout</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Zustand 的简洁性和对 TypeScript 的原生支持，使其成为现代 React 项目中处理全局客户端状态的绝佳选择。​</p><h3 id="数据请求-React-Query-管理服务端状态"><a href="#数据请求-React-Query-管理服务端状态" class="headerlink" title="数据请求: React Query - 管理服务端状态"></a>数据请求: React Query - 管理服务端状态</h3><p>React Query (现已更名为 TanStack Query) 是一个用于管理服务端状态的库。它彻底改变了我们处理数据获取、缓存、同步和更新的方式，让我们不再需要将 API 数据塞进全局状态管理器中。​<br>使用 <code>useQuery</code> 获取数据​<br><code>useQuery</code> 用于获取（GET）数据。它接收一个唯一的查询键（Query Key）和一个异步的获取函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;@tanstack/react-query&#x27;</span>;​</span><br><span class="line"><span class="keyword">import</span> &#123; api &#125; <span class="keyword">from</span> <span class="string">&#x27;../lib/api&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useBoard</span> = (<span class="params">boardId: string</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useQuery</span>(&#123;​</span><br><span class="line">    <span class="attr">queryKey</span>: [<span class="string">&#x27;board&#x27;</span>, boardId], <span class="comment">// 查询键，用于缓存和识别​</span></span><br><span class="line">    <span class="attr">queryFn</span>: <span class="function">() =&gt;</span> api.<span class="title function_">getBoard</span>(boardId), <span class="comment">// 异步获取函数​</span></span><br><span class="line">  &#125;);​</span><br><span class="line">&#125;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">BoardComponent</span> = (<span class="params">&#123; boardId &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: board, isLoading, isError &#125; = <span class="title function_">useBoard</span>(boardId);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (isLoading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading board...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;​</span><br><span class="line">  <span class="keyword">if</span> (isError) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error fetching board.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;board.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React Query 会自动为我们处理加载状态、错误状态、数据缓存、后台自动刷新等所有繁琐的工作。​<br>使用 <code>useMutation</code> 处理数据变更​<br><code>useMutation</code> 用于创建（<code>POST</code>）、更新（<code>PUT/PATCH</code>）或删除（<code>DELETE</code>）数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMutation, useQueryClient &#125; <span class="keyword">from</span> <span class="string">&#x27;@tanstack/react-query&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useCreateList</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>();​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMutation</span>(&#123;​</span><br><span class="line">    <span class="attr">mutationFn</span>: <span class="function">(<span class="params">newListData</span>) =&gt;</span> api.<span class="title function_">createList</span>(newListData),​</span><br><span class="line">    <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> &#123;​</span><br><span class="line">      <span class="comment">// 突变成功后，让与看板相关的查询失效，从而触发自动重新获取​</span></span><br><span class="line">      queryClient.<span class="title function_">invalidateQueries</span>(&#123; <span class="attr">queryKey</span>: [<span class="string">&#x27;board&#x27;</span>] &#125;);​</span><br><span class="line">    &#125;,​</span><br><span class="line">  &#125;);​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>invalidateQueries</code>，我们可以轻松地实现当数据变更后，自动更新页面上的相关数据，确保 UI 与服务端状态的同步。</p><h3 id="UI-与样式-Tailwind-CSS"><a href="#UI-与样式-Tailwind-CSS" class="headerlink" title="UI 与样式: Tailwind CSS"></a>UI 与样式: Tailwind CSS</h3><p>Tailwind CSS 是一个 “<strong>Utility-First</strong>” 的 CSS 框架。我们不再编写传统的 CSS 文件，而是直接在 JSX 中通过组合原子化的 CSS 类名来构建界面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p-6 max-w-sm mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shrink-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;h-12 w-12&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/logo.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;ChitChat Logo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-xl font-medium text-black&quot;</span>&gt;</span>ChitChat<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-slate-500&quot;</span>&gt;</span>You have a new message!<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>​</span><br></pre></td></tr></table></figure><p>这种方式的优势在于：​</p><ul><li><strong>开发速度极快</strong>：无需在 JSX 和 CSS 文件之间来回切换。​</li><li><strong>响应式设计</strong>：内置强大的响应式前缀（如 <code>md:, lg:</code>），轻松构建适配多端设备的界面。​</li><li><strong>高度可定制</strong>：可以通过 <code>tailwind.config.js</code> 文件轻松定制颜色、间距、字体等所有设计元素。​</li><li><strong>无需担心命名冲突</strong>：因为我们几乎不写自定义的 CSS 类名。</li></ul><h3 id="表单处理-React-Hook-Form-Zod"><a href="#表单处理-React-Hook-Form-Zod" class="headerlink" title="表单处理: React Hook Form + Zod"></a>表单处理: React Hook Form + Zod</h3><p>React Hook Form 是一个高性能、灵活且易于使用的表单库。它通过非受控组件的方式来减少不必要的渲染，从而在处理复杂表单时获得极佳的性能。​<br>我们将它与 Zod 结合，打造出既高性能又类型安全的表单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useForm &#125; <span class="keyword">from</span> <span class="string">&#x27;react-hook-form&#x27;</span>;​</span><br><span class="line"><span class="keyword">import</span> &#123; z &#125; <span class="keyword">from</span> <span class="string">&#x27;zod&#x27;</span>;​</span><br><span class="line"><span class="keyword">import</span> &#123; zodResolver &#125; <span class="keyword">from</span> <span class="string">&#x27;@hookform/resolvers/zod&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 1. 使用 Zod 定义表单的 schema 和校验规则​</span></span><br><span class="line"><span class="keyword">const</span> createCardSchema = z.<span class="title function_">object</span>(&#123;​</span><br><span class="line">  <span class="attr">title</span>: z.<span class="title function_">string</span>().<span class="title function_">min</span>(<span class="number">1</span>, <span class="string">&#x27;Title is required&#x27;</span>),​</span><br><span class="line">  <span class="attr">description</span>: z.<span class="title function_">string</span>().<span class="title function_">optional</span>(),​</span><br><span class="line">&#125;);​</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 2. 从 Zod schema 推断出 TypeScript 类型​</span></span><br><span class="line">type <span class="title class_">CreateCardData</span> = z.<span class="property">infer</span>&lt;<span class="keyword">typeof</span> createCardSchema&gt;;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CreateCardForm</span> = (<span class="params"></span>) =&gt; &#123;​</span><br><span class="line">  <span class="comment">// 3. 配置 useForm，使用 zodResolver​</span></span><br><span class="line">  <span class="keyword">const</span> &#123; register, handleSubmit, <span class="attr">formState</span>: &#123; errors &#125; &#125; = useForm&lt;<span class="title class_">CreateCardData</span>&gt;(&#123;​</span><br><span class="line">    <span class="attr">resolver</span>: <span class="title function_">zodResolver</span>(createCardSchema),​</span><br><span class="line">  &#125;);​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onSubmit</span> = (<span class="params">data: CreateCardData</span>) =&gt; &#123;​</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 这里的 data 是经过校验且类型安全的数据​</span></span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="title function_">handleSubmit</span>(onSubmit)&#125;&gt;​</span><br><span class="line">      &lt;input &#123;...<span class="title function_">register</span>(<span class="string">&#x27;title&#x27;</span>)&#125; /&gt;​</span><br><span class="line">      &#123;errors.<span class="property">title</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;errors.title.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;​</span><br><span class="line">      ​</span><br><span class="line">      &lt;textarea &#123;...<span class="title function_">register</span>(<span class="string">&#x27;description&#x27;</span>)&#125; /&gt;​</span><br><span class="line">      ​</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;<span class="title class_">Create</span> <span class="title class_">Card</span>&lt;/button&gt;​</span><br><span class="line">    &lt;/form&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个组合拳让我们仅需维护一份 Zod schema，就同时搞定了表单的类型定义、运行时校验和错误信息管理。</p><h3 id="组件库-shadcn-ui​"><a href="#组件库-shadcn-ui​" class="headerlink" title="组件库: shadcn&#x2F;ui​"></a>组件库: shadcn&#x2F;ui​</h3><p><code>shadcn/ui</code> 不是一个传统的组件库（如 Ant Design 或 MUI）。它不提供预先打包好的 npm 包，而是提供了一系列你可以直接复制粘贴到自己项目中的、制作精良的 React 组件。​</p><p>它的核心优势在于：​</p><ul><li><strong>你拥有代码</strong>：组件的代码直接存在于你的项目中（通常在 <code>src/components/ui</code>），你可以随心所欲地修改它，而不必担心库的更新破坏你的样式。​</li><li><strong>基于 Tailwind CSS</strong>：所有组件都使用 Tailwind CSS 构建，与我们的技术栈完美契合，定制样式变得异常简单。​</li><li><strong>可访问性</strong>：组件底层基于 Radix UI，保证了良好的可访问性（WAI-ARIA 标准）。​<br>通过其提供的 CLI 工具，我们可以轻松地将所需的组件（如 Button, Dialog, Input）添加到我们的项目中，然后像使用自己的组件一样使用和定制它们，极大地加速了高质量 UI 的开发进程。</li></ul><h2 id="质量保障与部署（拓展）"><a href="#质量保障与部署（拓展）" class="headerlink" title="质量保障与部署（拓展）"></a>质量保障与部署（拓展）</h2><h3 id="单元测试与集成测试-Jest-React-Testing-Library"><a href="#单元测试与集成测试-Jest-React-Testing-Library" class="headerlink" title="单元测试与集成测试 (Jest + React Testing Library)"></a>单元测试与集成测试 (Jest + React Testing Library)</h3><p><strong>编写测试是保障应用质量、防止未来代码迭代破坏现有功能的基石</strong>。​</p><ul><li>单元测试 (Unit Testing)：专注于测试应用中最小的独立单元，比如一个自定义 Hook 或一个简单的 UI 组件，确保其在各种输入下都能返回预期的输出。​</li><li>集成测试 (Integration Testing)：测试多个组件协同工作的场景，确保它们组合在一起时能够正确地完成一项功能，例如，测试一个完整的表单提交流程。​</li></ul><p><strong>在 React 生态中，最主流的测试组合是 Jest 和 React Testing Library (RTL)</strong>。</p><ul><li>Jest：一个功能全面的测试运行器（Test Runner），它提供了测试环境、断言库（Assertion Library）和 Mocking（模拟）等能力。​</li><li>React Testing Library：一个专注于测试组件行为的库。它的核心哲学是“像用户一样去测试”。我们不应该关心组件的内部实现细节（如 state 的值），而应该关心它在用户交互下渲染出的最终结果。例如，我们会测试“当点击这个按钮后，屏幕上是否出现了‘加载中...’的文本？”而不是“点击按钮后，组件的 isLoading state 是否变成了 true？”。​</li></ul><p>这种面向用户行为的测试方法，使得我们的测试用例更加健壮，即使未来重构了组件的内部逻辑，只要其对外行为不变，测试就依然能够通过。</p><h3 id="端到端测试-Cypress-Playwright-简介"><a href="#端到端测试-Cypress-Playwright-简介" class="headerlink" title="端到端测试 (Cypress&#x2F;Playwright) 简介"></a>端到端测试 (Cypress&#x2F;Playwright) 简介</h3><p>端到端（End-to-End, E2E）测试是最高层级的测试，它从头到尾完整地模拟一个真实用户的操作路径。E2E 测试会在一个真实的浏览器环境中自动执行一系列操作，如访问页面、输入文本、点击按钮、验证页面跳转和内容显示，从而确保整个应用（包括前端、后端接口、数据库等）作为一个整体能够正常工作。​</p><p>对于我们的看板项目，一个典型的 E2E 测试用例可能是：​</p><ul><li>自动打开浏览器并访问登录页面。​</li><li>输入用户名和密码并点击登录。​</li><li>验证页面是否跳转到了看板主页。​</li><li>点击“创建新列表”按钮，输入列表名称并确认。​</li><li>验证新的列表是否出现在了看板上。​</li></ul><p><strong>Cypress</strong> 和 <strong>Playwright</strong> 是当前最流行的 E2E 测试框架。它们提供了强大的 API 来驱动浏览器进行自动化操作和断言，并附带了优秀的调试工具，可以让我们清晰地看到每一步的执行情况。</p><h3 id="Vite-构建与打包优化"><a href="#Vite-构建与打包优化" class="headerlink" title="Vite 构建与打包优化"></a>Vite 构建与打包优化</h3><p>我们在开发过程中使用的 npm run dev 命令启动的是一个为快速反馈而优化的开发服务器。当需要将应用部署到线上时，我们必须执行生产环境构建。​<br>通过运行 <code>npm run build</code> 命令，Vite 会将我们的源代码进行一系列优化处理，生成一套高度优化的</p><p>静态文件（HTML, CSS, JavaScript），以便在用户的浏览器中实现最佳性能。这个过程主要包括：​</p><ul><li><strong>打包 (Bundling)</strong>：将多个模块文件合并成少数几个文件，以减少网络请求次数。​</li><li><strong>代码分割 (Code Splitting)</strong>：智能地将代码拆分成多个小块（chunks），实现按需加载（例如，访问某个页面才加载该页面的代码）。​</li><li><strong>Tree Shaking</strong>：自动移除代码中从未被使用过的“死代码”，减小打包体积。​</li><li><strong>压缩 (Minification)</strong>：移除代码中的空格、注释，并缩短变量名，进一步压缩文件大小。​</li></ul><p>Vite 的构建过程开箱即用且性能卓越，为我们的应用上线提供了坚实的性能基础。</p><h3 id="CI-CD-与自动化部署-GitHub-Actions-Vercel-Netlify-​"><a href="#CI-CD-与自动化部署-GitHub-Actions-Vercel-Netlify-​" class="headerlink" title="CI&#x2F;CD 与自动化部署 (GitHub Actions, Vercel&#x2F;Netlify)​"></a>CI&#x2F;CD 与自动化部署 (GitHub Actions, Vercel&#x2F;Netlify)​</h3><p>手动将打包后的文件上传到服务器是一种低效且容易出错的部署方式。现代化的工作流采用 CI&#x2F;CD（持续集成&#x2F;持续部署）来实现部署的自动化。​</p><ul><li>持续集成 (Continuous Integration, CI)：当开发者将代码推送到 GitHub 等代码仓库时，会自动触发一系列预设的检查流程，例如运行代码规范检查（ESLint）和自动化测试（Jest）。只有所有检查都通过，代码才被认为是“可集成的”。​</li><li>持续部署 (Continuous Deployment, CD)：一旦 CI 流程成功通过，会自动将应用构建并部署到生产服务器上，实现新版本的发布。​</li></ul><p>我们可以使用 GitHub Actions 来搭建 CI 流程。只需在项目中创建一个 YAML 配置文件，即可定义在代码推送时需要执行的命令。​<br>而 Vercel 和 Netlify 则是极受欢迎的现代化前端应用托管平台。它们与 GitHub 等代码仓库深度集成。</p><p>我们只需将项目仓库授权给 Vercel&#x2F;Netlify，它们就会自动完成所有部署工作：​</p><ul><li>监听到我们向主分支推送了新的代码。​</li><li>拉取最新的代码。​</li><li>自动执行 npm run build 命令进行打包。​</li><li>将打包后的静态文件部署到其全球 CDN（内容分发网络）上。​</li><li>新版本上线，全程无需人工干预。</li></ul><h1 id="源码与原理篇-迈向专家之路"><a href="#源码与原理篇-迈向专家之路" class="headerlink" title="源码与原理篇 - 迈向专家之路"></a>源码与原理篇 - 迈向专家之路</h1><h2 id="React-核心工作流"><a href="#React-核心工作流" class="headerlink" title="React 核心工作流"></a>React 核心工作流</h2><p>你是否曾好奇，当你在组件中调用 setState 后，React 内部究竟发生了怎样一番天翻地覆的变化，才最终将新的 UI 精准地呈现在屏幕上？本章将为你揭示这个核心工作流，从虚拟 DOM 的概念，到开创性的 Fiber 架构，再到完整的协调过程，让你对 React 的每一次更新都了然于胸。</p><h3 id="虚拟-DOM-Virtual-DOM-与-Diffing-算法"><a href="#虚拟-DOM-Virtual-DOM-与-Diffing-算法" class="headerlink" title="虚拟 DOM (Virtual DOM) 与 Diffing 算法"></a>虚拟 DOM (Virtual DOM) 与 Diffing 算法</h3><p>直接操作浏览器的真实 DOM 是一项成本高昂的操作。频繁地增删改查 DOM 元素，会引发浏览器的重排（Reflow）和重绘（Repaint），严重影响页面性能。为了解决这个问题，React 引入了一个设计——虚拟 <strong>DOM (Virtual DOM)</strong>。​<br>虚拟 DOM，顾名思义，它并非真实的 DOM。它是一个存在于内存中的、轻量级的 JavaScript 对象，是真实 DOM 结构的一份“蓝图”或“快照”。</p><p>当组件的状态发生变化时，React 并不会立即去操作真实 DOM，而是会执行以下步骤：​</p><ul><li>根据新的状态，在内存中构建一棵新的虚拟 DOM 树。​</li><li>将这棵新树与上一次渲染时保存的旧虚拟 DOM 树进行比较。​</li><li>这个比较的过程，就是著名的 Diffing 算法。它能够高效地计算出两棵树之间的最小差异。​</li><li>最后，React 将这些计算出的“差异”，以最优的方式、一次性地应用到真实的 DOM 上，从而最大限度地减少了对真实 DOM 的操作。​</li></ul><p>Diffing 算法之所以高效，是因为它建立在几个合理的启发式策略之上：​</p><ul><li>不同类型的元素会产生不同的树：如果一个元素的类型从 <code>&lt;div&gt;</code> 变成了 <code>&lt;span&gt;</code>，React 不会去尝试比较它们内部的差异，而是直接销毁旧的 div 及其所有子节点，然后创建一个全新的 <code>&lt;span&gt;</code>。​</li><li>可以通过 <code>key</code> 属性来暗示元素的稳定性：在渲染一个列表时，<code>key</code> 属性扮演着至关重要的角色。它就像是每个元素的“身份证”。通过 <code>key</code>，React 能够识别出哪些元素只是移动了位置，而不是被删除和重新创建，从而进行高效的移动操作，而非销毁重建。这正是我们强调列表渲染中 key 重要性的根本原因。</li></ul><h3 id="深入-Fiber-架构：可中断、可恢复的渲染单元"><a href="#深入-Fiber-架构：可中断、可恢复的渲染单元" class="headerlink" title="深入 Fiber 架构：可中断、可恢复的渲染单元"></a>深入 Fiber 架构：可中断、可恢复的渲染单元</h3><p>在 React 16 之前，协调过程是同步且不可中断的。当一个大型组件树需要更新时，React 会递归地遍历整棵树，这个过程会长时间占用浏览器的主线程。如果此时用户进行了输入或点击，页面将无法响应，出现卡顿。​<br>为了解决这个问题，React 团队重写了整个协调引擎，推出了 Fiber 架构。​<br>Fiber 的核心思想是将渲染&#x2F;更新过程拆分为许多小的、可独立处理的工作单元。每一个工作单元就是一个 Fiber 节点。React 不再是一口气递归地完成整个更新，而是以 Fiber 节点为单位进行处理。每完成一个或几个单元的工作后，React 都会将主线程的控制权交还给浏览器，让浏览器有机会去处理更高优先级的任务（如用户输入）。随后，React 会在下一次浏览器空闲时，从上次中断的地方继续它的工作。​<br>一个 Fiber 节点是一个包含了组件类型、props、state、以及指向其父节点、子节点和兄弟节点的指针的 JavaScript 对象。这些指针将整个组件树连接成一个链表结构，使得遍历和工作调度可以随时暂停和恢复。​<br>​</p><blockquote><p><strong>一个类比</strong>：​<br>旧的协调机制就像是一次性把一幅长画卷从头画到尾，中途不能停笔。而 Fiber 架构则像是将画卷分割成无数个小方格，每次只画一格，画完一格就抬头看看有没有更紧急的事情，如果没有，再继续画下一格。​</p></blockquote><p>正是这种可中断、可恢复的特性，为 React 后续实现并发渲染等高级功能奠定了基础。</p><h3 id="Reconciliation-协调-过程详解"><a href="#Reconciliation-协调-过程详解" class="headerlink" title="Reconciliation (协调) 过程详解"></a>Reconciliation (协调) 过程详解</h3><p>在 Fiber 架构下，从 setState 被调用到最终 UI 更新的完整协调过程，被清晰地划分为两个阶段：​</p><p><strong>第一阶段：Render Phase (渲染阶段)​</strong></p><ul><li>这个阶段是异步的、可中断的。​</li><li>React 从根 Fiber 节点开始，遍历整个 Fiber 树。对于每一个节点，它会调用组件的渲染函数，执行 Diffing 算法，计算出需要进行的 DOM 变更（如“新增节点”、“更新属性”、“删除节点”等），并将这些变更信息记录在 Fiber 节点上。​</li><li>由于这个阶段只是在内存中进行计算，并不会产生任何对用户可见的副作用，所以即使它被更高优先级的任务（如用户输入）打断，然后被丢弃或重做，也不会造成 UI 的不一致。​</li></ul><p><strong>第二阶段：Commit Phase (提交阶段)​</strong></p><ul><li>这个阶段是同步的、不可中断的。​</li><li>一旦 Render Phase 成功完成，React 就拿到了一个完整的“变更清单”。它会进入 Commit Phase，将这个清单中的所有变更，一次性地、同步地应用到真实 DOM 上。​</li><li>这个阶段必须是同步且不可中断的，以确保用户不会看到渲染到一半的、不完整的 UI 状态。这个过程通常非常快。​</li></ul><p>通过这两个阶段的分离，React 实现了既能处理耗时更新任务而又不阻塞用户界面的目标。</p><h2 id="并发渲染揭秘"><a href="#并发渲染揭秘" class="headerlink" title="并发渲染揭秘"></a>并发渲染揭秘</h2><p>基于 Fiber 架构的可中断特性，React 19 正式将并发（Concurrency）作为其核心能力。并发不是一个具体的功能，而是一种更底层的渲染机制，它使得 React 应用能够更加流畅和智能地响应用户交互。</p><h3 id="什么是并发？它解决了什么问题？"><a href="#什么是并发？它解决了什么问题？" class="headerlink" title="什么是并发？它解决了什么问题？"></a>什么是并发？它解决了什么问题？</h3><p>首先需要明确，并发不是并行。并行是指在同一时刻同时执行多个任务（需要多核处理器）。而并发是指一种能够同时处理多个任务，并在它们之间根据优先级进行切换的机制。​<br>它解决的核心问题是渲染阻塞。设想一个场景：在一个搜索框中输入文字，下方会根据输入实时过滤一个巨大的列表。在没有并发的模式下，每一次按键都会触发列表的重新渲染。如果列表渲染耗时较长（比如 200ms），那么用户的输入操作就会被阻塞，感觉到明显的延迟和卡顿。​</p><p>在并发模式下，React 能够更智能地处理这种情况。它会将用户的输入（高优先级）和列表的渲染（低优先级）识别为两个不同的更新任务。当用户正在输入时，React 会优先处理按键的反馈（让字符立即显示在输入框中），同时它可以中断正在进行的、耗时的列表渲染，等用户输入完毕后，再以最新的搜索词恢复列表的渲染工作。这使得应用始终保持高度的响应性。</p><h3 id="startTransition-和-useTransition-的原理与应用"><a href="#startTransition-和-useTransition-的原理与应用" class="headerlink" title="startTransition 和 useTransition 的原理与应用"></a>startTransition 和 useTransition 的原理与应用</h3><p>为了让开发者能够利用并发的能力，React 提供了 startTransition 和 useTransition 这两个 API。它们的作用是，让我们可以将某些状态更新标记为“非紧急”的。​</p><ul><li>startTransition：这是一个函数，你可以将一个或多个 setState 调用包裹在其中。被包裹的更新将被视为“过渡更新”（Transition Update），React 会以较低的优先级来处理它，并且在渲染过程中允许被更高优先级的更新打断。​</li><li>useTransition: 这是一个 Hook，它返回一个 isPending 状态和一个 startTransition 函数。isPending 状态可以让我们在过渡更新正在进行时，向用户显示一个加载指示器，从而优化用户体验。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useTransition &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FilterableList</span> = (<span class="params">&#123; items &#125;</span>) =&gt; &#123;​</span><br><span class="line">  <span class="keyword">const</span> [filter, setFilter] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);​</span><br><span class="line">  <span class="keyword">const</span> [isPending, startTransition] = <span class="title function_">useTransition</span>();​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleFilterChange</span> = (<span class="params">e</span>) =&gt; &#123;​</span><br><span class="line">    <span class="comment">// startTransition 将 setFilter 的更新标记为非紧急​</span></span><br><span class="line">    <span class="title function_">startTransition</span>(<span class="function">() =&gt;</span> &#123;​</span><br><span class="line">      <span class="title function_">setFilter</span>(e.<span class="property">target</span>.<span class="property">value</span>);​</span><br><span class="line">    &#125;);​</span><br><span class="line">  &#125;;​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> filteredItems = items.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">includes</span>(filter));​</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> (​</span><br><span class="line">    &lt;div&gt;​</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;handleFilterChange&#125; /&gt;​</span><br><span class="line">      &#123;isPending &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Updating list...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;​</span><br><span class="line">      &lt;ul&gt;​</span><br><span class="line">        &#123;filteredItems.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;​</span><br><span class="line">      &lt;/ul&gt;​</span><br><span class="line">    &lt;/div&gt;​</span><br><span class="line">  );​</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，即使用户快速输入，输入框的响应也始终是流畅的，因为 setFilter 的更新被降级处理，不会阻塞主线程。</p><h3 id="Lane-模型：任务优先级的内部实现"><a href="#Lane-模型：任务优先级的内部实现" class="headerlink" title="Lane 模型：任务优先级的内部实现"></a>Lane 模型：任务优先级的内部实现</h3><p>那么，React 内部是如何管理这些不同优先级的任务的呢？其核心机制就是 Lane 模型（在早期版本中是 ExpirationTime 模型）。​</p><p>这是一个相对底层的概念，我们可以将其理解为一个任务优先级的表示系统。​</p><ul><li>每一个更新任务（如一次点击事件触发的 setState，或一次 startTransition 中的更新）都会被分配到一个或多个 “Lane”（车道）上。​</li><li>不同的 Lane 代表了不同的优先级。例如，同步的、由用户交互直接触发的更新会分配到高优先级的 Lane，而过渡更新则会分配到低优先级的 Lane。​</li><li>React 的调度器在工作时，会像一个交通调度员一样，总是检查所有“车道”，并优先处理最高优先级车道上的任务。​</li></ul><h2 id="Hooks-实现原理"><a href="#Hooks-实现原理" class="headerlink" title="Hooks 实现原理"></a>Hooks 实现原理</h2><p>Hooks 的出现极大地简化了 React 的组件逻辑，但它看似神奇的背后，依赖于一套简单而严格的规则和巧妙的内部实现。理解其原理，将彻底打消你对 Hooks 的所有困惑。</p><h3 id="Hooks-为什么必须在顶层调用？"><a href="#Hooks-为什么必须在顶层调用？" class="headerlink" title="Hooks 为什么必须在顶层调用？"></a>Hooks 为什么必须在顶层调用？</h3><p>这是 React 面试中最经典的问题之一，答案也直指 Hooks 的核心实现机制。React Hooks 的规则是：禁止在循环、条件或嵌套函数中调用 Hooks。​</p><p>原因在于：React 是依靠 Hooks 在每次渲染时的稳定调用顺序来识别和关联它们的状态的。​</p><p>在 React 内部，它会为每个组件维护一个存储 Hooks 数据的链表（或数组）。当组件第一次渲染时，每调用一个 Hook (useState, useEffect 等)，就会向这个链表中添加一个节点来存储该 Hook 的数据。​</p><p>当组件重新渲染时，React 会重置一个指向链表头部的内部指针。每当再次执行到 Hooks 调用时，它就将指针后移一位，并读取该节点的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，描绘 React 内部的工作方式​</span></span><br><span class="line"><span class="keyword">let</span> hooks, cursor;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">Component</span>) &#123;​</span><br><span class="line">  cursor = <span class="number">0</span>; <span class="comment">// 每次渲染前重置指针​</span></span><br><span class="line">  hooks = component.<span class="property">hooks</span>; <span class="comment">// 获取组件的 hooks 链表​</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;​</span><br><span class="line">&#125;​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialValue</span>) &#123;​</span><br><span class="line">  <span class="comment">// 读取当前指针位置的 hook 数据​</span></span><br><span class="line">  <span class="keyword">const</span> hook = hooks[cursor]; ​</span><br><span class="line">  <span class="comment">// ...​</span></span><br><span class="line">  cursor++; <span class="comment">// 将指针移到下一位​</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">state</span>, hook.<span class="property">setState</span>];​</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们将 Hooks 放在一个条件语句中，当条件在不同渲染中发生变化时，Hooks 的调用顺序就会被打乱。React 的指针就会指向错误的 Hook 数据节点，导致状态错乱，引发严重的 bug。因此，React 强制要求 Hooks 的调用顺序在每次渲染中都必须保持绝对一致。​<br>​</p><h3 id="useState-和-useEffect-的内部数据结构-链表-​"><a href="#useState-和-useEffect-的内部数据结构-链表-​" class="headerlink" title="useState 和 useEffect 的内部数据结构 (链表)​"></a>useState 和 useEffect 的内部数据结构 (链表)​</h3><p>如上所述，每个函数式组件的 Fiber 节点上，都有一个 memoizedState 属性，它指向一个由该组件所有 Hooks 构成的链表的头节点。​</p><ul><li>对于 useState，链表中的每个节点（一个 Hook 对象）大致包含：​</li><li>memoizedState: 存储当前的状态值。​</li><li>queue: 一个用于存放待处理更新的队列（当你调用 setState 时，更新任务就被放入这个队列）。​</li><li>next: 指向下一个 Hook 节点的指针。​</li><li>对于 useEffect，其对应的 Hook 对象则会存储：​</li><li>create: 副作用函数本身。​</li><li>deps: 依赖项数组。​</li><li>destroy: 上一次副作用返回的清理函数。​</li><li>next: 指向下一个 Hook 节点的指针。​</li></ul><p>正是这个在组件 Fiber 节点上稳定存在的链表结构，让函数式组件在多次渲染之间拥有了持久化状态和副作用的能力。​<br>​</p><h3 id="从源码角度理解-Hooks-的工作机制​"><a href="#从源码角度理解-Hooks-的工作机制​" class="headerlink" title="从源码角度理解 Hooks 的工作机制​"></a>从源码角度理解 Hooks 的工作机制​</h3><p>我们无需深入源码的每一行，但理解其关键的函数调用流程，可以建立起一个清晰的心智模型。​<br>当 React 渲染一个函数式组件时，它实际上是在调用一个名为 <code>renderWithHooks</code> 的内部函数。这个函数在执行我们编写的组件代码之前，会进行一系列准备工作，最主要的就是设置好当前正在渲染的组件上下文，并将内部的 Hooks 指针（<code>cursor</code>）重置到链表头部。​</p><p>然后，它开始执行我们的组件函数。当我们的代码调用 <code>useState</code> 或 <code>useEffect</code> 时，这些 Hooks 函数能够从准备好的上下文中读取到当前组件的 Fiber 节点和正确的 Hooks 链表节点，从而返回正确的状态或注册副作用。​</p><p>当我们的组件函数执行完毕后，<code>renderWithHooks</code> 还会进行一些收尾工作。这个“准备-执行-收尾”的包装过程，就是 Hooks 能够在看似普通的 JavaScript 函数调用中，与 React 的内部状态管理机制安全交互的秘密所在。​<br>​</p><h1 id="相关面试题​"><a href="#相关面试题​" class="headerlink" title="相关面试题​"></a>相关面试题​</h1><h2 id="基础部分​"><a href="#基础部分​" class="headerlink" title="基础部分​"></a>基础部分​</h2><ul><li>React 中的 key 有什么作用？为什么它在列表中是必须的？​</li><li>useState 和 useEffect 的作用分别是什么？请描述 useEffect 的依赖数组如何工作。​</li><li>什么是 JSX？它和普通的 HTML 有什么区别？它最终会被编译成什么？​</li><li>函数式组件和类组件有什么区别？你为什么更倾向于使用函数式组件？​</li><li>如何在 React 中处理事件？React 的合成事件系统（SyntheticEvent）是什么？​<br>​</li></ul><h2 id="进阶与-React-19-部分​"><a href="#进阶与-React-19-部分​" class="headerlink" title="进阶与 React 19 部分​"></a>进阶与 React 19 部分​</h2><ul><li>[React 19] 什么是 React Actions？它解决了传统表单处理的哪些痛点？​</li><li>[React 19] useActionState 和 useFormStatus 分别是用来做什么的？它们之间有什么关系？​</li><li>[React 19] 请解释 use Hook 的作用。它和 await 在异步函数中有什么异同？​</li><li>[React 19] 什么是乐观更新（Optimistic UI）？useOptimistic Hook 是如何帮助我们实现它的？​</li><li>[React 19] 你对 React Compiler 有什么了解？它试图解决什么问题？这对我们编写 React 代码的方式会有什么影响？​</li><li>useMemo 和 useCallback 的区别和使用场景是什么？在有了 React Compiler 之后，我们还需要手动使用它们吗？​</li><li>什么是自定义 Hook？请举例说明你如何创建一个自定义 Hook 来复用逻辑。​</li><li>如何在 React + TypeScript 项目中为组件的 Props 定义类型？React.FC 有什么优缺点？​<br>​</li></ul><h2 id="实战与生态部分​"><a href="#实战与生态部分​" class="headerlink" title="实战与生态部分​"></a>实战与生态部分​</h2><ul><li>请比较几种常见的 React 状态管理方案（如 Redux, Zustand, Context API）。​</li><li>你在项目中使用过哪些样式方案？请谈谈 Tailwind CSS (Utility-First) 和 CSS-in-JS (如 styled-components) 的优缺点。​</li><li>React Router 是如何实现客户端路由的？Link 组件和 <a>标签有什么不同？​</a></li><li>什么是 React Testing Library？它的核心测试哲学是什么？​</li><li>如何对一个 React 应用进行性能优化？请列举至少 3 种方法。​<br>​</li></ul><h2 id="原理部分​"><a href="#原理部分​" class="headerlink" title="原理部分​"></a>原理部分​</h2><ul><li>请简述 React 的 Virtual DOM 和 Diffing 算法的工作原理。​</li><li>什么是 React Fiber？它为什么被引入？​</li><li>什么是并发渲染 (Concurrent Rendering)？它给用户体验带来了哪些提升？​</li><li>Hooks 的实现原理是什么？为什么 Hooks 不能在条件语句或循环中调用？</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://xiaowu95.wang">小五</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://xiaowu95.wang/posts/70e8efec/">https://xiaowu95.wang/posts/70e8efec/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiaowu95.wang" target="_blank">小五的个人杂货铺</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post-share"><div class="social-share" data-image="/img/nba-logo13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>感谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wxpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-lazy-src="/img/wxpay.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-lazy-src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/c75c82a0/" title="使用 TypeScript 创建 Koa 服务器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/nba-logo19.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">使用 TypeScript 创建 Koa 服务器</div></div><div class="info-2"><div class="info-item-1">概述尽管使用 NodeJS 搭建 HTTP 服务器早已是 Web 开发者们的家常便饭，但结合时下最热门的 TypeScript 却能带来更棒的开发体验。今天，我们就来一起尝试将它们结合起来，快速搭建一个健壮的 Koa 服务。 Koa 基础环境搭建我们从 Koa 开始，它是一个轻量且富有表现力的 NodeJS Web 框架。 安装核心依赖安装 Koa 及其常用的中间件 (Middleware)： 1npm install koa koa-bodyparser koa-json koa-logger koa-router 注意： koa-bodyparser、koa-json、koa-logger 和 koa-router 都属于 Koa 的中间件。 编写基础 Koa 代码首先，创建 src 目录用于存放源代码，并在其中创建 index.js 文件： 123// 文件结构src└── index.js 基础 Koa 服务 (index.js)： 123456789101112131415161718192021222324252627import Koa from &#x27...</div></div></div></a><a class="pagination-related" href="/posts/662dec76/" title="ElementPlus实战"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/nba-logo28.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ElementPlus实战</div></div><div class="info-2"><div class="info-item-1">摘自：https://qiuli.site/2025/10/16/elementplus%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/ 简介Element UI 是一款基于 Vue.js 2.0 的开源桌面端组件库，旨在帮助开发者快速构建现代化、高效且风格统一的 Web 应用程序。ElementPlus是 Element UI 的官方升级版本，专为 Vue 3.0 设计，完全兼容 Vue 3 的 Composition API 和 TypeScript，并继承了 Element UI 的核心设计理念与组件生态。我们现在使用ElementPlus来实现一套后台管理项目。 项目简介我们这次实现的项目叫‘realworld’，是一个简单的博客网站；这个项目是一个专门用户练手的demo，有各种语言的实现方式，地址是：https://main--realworld-docs.netlify.app/；我们可以找到数据库表、接口标准，前后端的数据格式等等；我使用Java简单实现了后端项目，代码地址为：https://gitee.com/qiuli-zero/rea...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/7e8a6a89/" title="记录几种flex布局实例代码模板"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/nba-logo5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-11-04</div><div class="info-item-2">记录几种flex布局实例代码模板</div></div><div class="info-2"><div class="info-item-1">公共css 123456789101112131415161718192021.body &#123; margin: 0;&#125;.header, .footer, .article, .aside &#123; color: #fff; min-height: 60px; text-align: center; display: flex; align-items: center; justify-content: center;&#125;.header, .footer &#123; background-color: #7dbcea;&#125;.aside &#123; background-color: #3ba0e9;&#125;.article &#123; min-height: 300px; background-color: #108ee9;&#125; 1234567891011121314151617181920212223&lt;view class=&quot;body&quot;&gt; &lt;view cl...</div></div></div></a><a class="pagination-related" href="/posts/662dec76/" title="ElementPlus实战"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/nba-logo28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-11-04</div><div class="info-item-2">ElementPlus实战</div></div><div class="info-2"><div class="info-item-1">摘自：https://qiuli.site/2025/10/16/elementplus%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/ 简介Element UI 是一款基于 Vue.js 2.0 的开源桌面端组件库，旨在帮助开发者快速构建现代化、高效且风格统一的 Web 应用程序。ElementPlus是 Element UI 的官方升级版本，专为 Vue 3.0 设计，完全兼容 Vue 3 的 Composition API 和 TypeScript，并继承了 Element UI 的核心设计理念与组件生态。我们现在使用ElementPlus来实现一套后台管理项目。 项目简介我们这次实现的项目叫‘realworld’，是一个简单的博客网站；这个项目是一个专门用户练手的demo，有各种语言的实现方式，地址是：https://main--realworld-docs.netlify.app/；我们可以找到数据库表、接口标准，前后端的数据格式等等；我使用Java简单实现了后端项目，代码地址为：https://gitee.com/qiuli-zero/rea...</div></div></div></a><a class="pagination-related" href="/posts/e930893f/" title="Vue3入门"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/nba-logo16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-11-04</div><div class="info-item-2">Vue3入门</div></div><div class="info-2"><div class="info-item-1">摘自：https://qiuli.site/2025/08/10/vue3%E5%85%A5%E9%97%A8/ 简介Vue.js（简称Vue）是一款用于构建用户界面的渐进式JavaScript框架，本文我们就简单的学习一下Vue的使用。 知识图谱概览我们学习的时候，先从总体上对事务有一个认识还是非常重要的，我从网上找了一张图片，从整体上介绍了一下学习的内容；我们的文章也会按照这个结构来编写 构建工程项目安装Node.js我们可以去官网下载长期支持版本（LTS版本），点击安装即可；安装后再使用命令行查看是否安装成功 123# 查看是否安装了node.jsnode -vnpm -v 基于 Vite 创建一个Vue项目vite是什么？问一问deepseek： 1Vite 是一款由 Vue.js 创始人尤雨溪（Evan You）开发的现代前端构建工具，旨在通过原生 ES 模块（ESM）和按需编译等特性，显著提升开发效率和构建速度。 我们打开命令行，进入希望创建工程的目录，输入命令 1npm create vite@latest 然后按照提示输入项目名称、选择框架（选vue）和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小五</div><div class="author-info-description">Tomorrow will be better,Everything will be fine</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">554</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/wang-xiaowu"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="/random" target="_blank" title="随便逛逛"><i class="fa-solid fa-shuffle"></i></a><a class="social-icon" href="mailto:wangxiaowu950330@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/30655189?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%8E%B0%E4%BB%A3%E5%8C%96-React-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">基础篇 - 现代化 React 开发入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">开发环境与核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E6%80%9D%E6%83%B3%E4%B8%8E%E5%89%8D%E7%AB%AF%E6%BC%94%E8%BF%9B"><span class="toc-number">1.1.1.</span> <span class="toc-text">React 思想与前端演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Vite-%E6%90%AD%E5%BB%BA-React-TypeScript-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用 Vite 搭建 React + TypeScript 开发环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5-JSX-%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">深入 JSX 语法与实践技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8E-Class-%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.4.</span> <span class="toc-text">函数式组件与 Class 组件对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A0%B8%E5%BF%83"><span class="toc-number">1.2.</span> <span class="toc-text">组件化开发核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Props-%E4%B8%8E%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Props 与组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TypeScript-%E5%AE%9A%E4%B9%89-Props-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用 TypeScript 定义 Props 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">事件处理与合成事件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%85%A5%E9%97%A8%EF%BC%9AuseState-Hook-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">状态管理入门：useState Hook 详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93-key-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">条件渲染与列表渲染 (key 的重要性)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5-Hooks-%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.</span> <span class="toc-text">深入 Hooks 与生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%A4%84%E7%90%86%EF%BC%9AuseEffect-Hook-%E8%AF%A6%E8%A7%A3-%E6%8C%82%E8%BD%BD%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">副作用处理：useEffect Hook 详解 (挂载、更新、卸载)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD-Mount"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">模拟组件挂载 (Mount)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0-Update"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">模拟组件更新 (Update)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BB%84%E4%BB%B6%E5%8D%B8%E8%BD%BD-Unmount-%E4%B8%8E-%E6%B8%85%E7%90%86%E5%89%AF%E4%BD%9C%E7%94%A8%E2%80%8B"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">模拟组件卸载 (Unmount) 与 清理副作用​</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect-%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1"><span class="toc-number">1.3.2.</span> <span class="toc-text">useEffect 的依赖项数组与常见陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-useRef-%E8%AE%BF%E9%97%AE-DOM-%E5%92%8C%E5%AD%98%E5%82%A8%E5%8F%AF%E5%8F%98%E5%80%BC"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用 useRef 访问 DOM 和存储可变值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useRef-%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%94%A8%E9%80%94%EF%BC%9A%E2%80%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">useRef 主要有两个用途：​</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-DOM-%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">访问 DOM 元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BB%BB%E6%84%8F%E5%8F%AF%E5%8F%98%E5%80%BC%EF%BC%88%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%EF%BC%89%E2%80%8B"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">存储任意可变值（实例变量）​</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E4%B8%8E-Hooks-%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.4.</span> <span class="toc-text">TypeScript 与 Hooks 的类型推断与显式声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useState-%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">useState 的类型​</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useRef-%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%8B"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">useRef 的类型​</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%AF%87-%E6%8E%A2%E7%B4%A2-React-19-%E6%96%B0%E8%8C%83%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">进阶篇 - 探索 React 19 新范式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-19-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">React 19 核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Actions-%E8%A1%A8%E5%8D%95%E4%BA%A4%E4%BA%92%E7%9A%84%E9%9D%A9%E5%91%BD"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">Actions: 表单交互的革命</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E-use-Hook"><span class="toc-number">2.1.1.</span> <span class="toc-text">并发与 use Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.2.</span> <span class="toc-text">其他新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Compiler-%E7%90%86%E5%BF%B5%E7%AF%87"><span class="toc-number">2.2.</span> <span class="toc-text">React Compiler (理念篇)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9A%84%E7%97%9B%E7%82%B9%EF%BC%9AuseMemo-useCallback-%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">手动优化的痛点：useMemo, useCallback 的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Compiler-%E2%80%9CForget%E2%80%9D-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-number">2.2.2.</span> <span class="toc-text">React Compiler (“Forget”) 的设计哲学与目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%AE%B0%E5%BF%86%E5%8C%96-Memoization"><span class="toc-number">2.2.3.</span> <span class="toc-text">Compiler 如何实现自动记忆化 (Memoization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%8E%B0%E6%9C%89%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D%E4%B8%8E%E8%BF%81%E7%A7%BB%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.4.</span> <span class="toc-text">对现有代码库的影响与迁移策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-Hooks-%E4%B8%8E%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">高级 Hooks 与状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%EF%BC%9AuseReducer-vs-useState%E2%80%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">复杂状态逻辑：useReducer vs useState​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%9AuseContext-%E4%B8%8E%E6%80%A7%E8%83%BD%E9%99%B7%E9%98%B1"><span class="toc-number">2.3.2.</span> <span class="toc-text">全局状态管理：useContext 与性能陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9AReact-memo-useMemo-useCallback-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">手动性能优化：React.memo, useMemo, useCallback 的正确使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks%EF%BC%9A%E5%B0%81%E8%A3%85%E9%80%BB%E8%BE%91%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8-%E5%90%AB-TS-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">自定义 Hooks：封装逻辑与实现复用 (含 TS 泛型)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">TypeScript 高级应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%B3%9B%E5%9E%8B-Hooks"><span class="toc-number">2.4.1.</span> <span class="toc-text">泛型组件与泛型 Hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B2%BE%E7%A1%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">React 事件对象的精确类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88-Zod-%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.4.3.</span> <span class="toc-text">结合 Zod 进行运行时类型校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7-Utility-Types-%E5%9C%A8%E7%BB%84%E4%BB%B6-Props-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">高级类型工具 (Utility Types) 在组件 Props 中的应用</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E7%AF%87-%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">实战篇 - 构建企业级项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">项目启动与架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">项目需求分析与技术选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">3.1.2.</span> <span class="toc-text">搭建项目结构与配置代码规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%EF%BC%9AReact-Router-v6"><span class="toc-number">3.1.3.</span> <span class="toc-text">路由管理：React Router v6+</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91"><span class="toc-number">3.2.</span> <span class="toc-text">核心功能开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Zustand-%E8%BD%BB%E9%87%8F%E3%80%81%E9%AB%98%E6%95%88%E7%9A%84%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">状态管理: Zustand - 轻量、高效的全局状态管理方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-React-Query-%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">数据请求: React Query - 管理服务端状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-%E4%B8%8E%E6%A0%B7%E5%BC%8F-Tailwind-CSS"><span class="toc-number">3.2.3.</span> <span class="toc-text">UI 与样式: Tailwind CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86-React-Hook-Form-Zod"><span class="toc-number">3.2.4.</span> <span class="toc-text">表单处理: React Hook Form + Zod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%BA%93-shadcn-ui%E2%80%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">组件库: shadcn&#x2F;ui​</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">质量保障与部署（拓展）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95-Jest-React-Testing-Library"><span class="toc-number">3.3.1.</span> <span class="toc-text">单元测试与集成测试 (Jest + React Testing Library)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95-Cypress-Playwright-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">端到端测试 (Cypress&#x2F;Playwright) 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vite-%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">Vite 构建与打包优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CI-CD-%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-GitHub-Actions-Vercel-Netlify-%E2%80%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">CI&#x2F;CD 与自动化部署 (GitHub Actions, Vercel&#x2F;Netlify)​</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AF%87-%E8%BF%88%E5%90%91%E4%B8%93%E5%AE%B6%E4%B9%8B%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">源码与原理篇 - 迈向专家之路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">React 核心工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM-Virtual-DOM-%E4%B8%8E-Diffing-%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">虚拟 DOM (Virtual DOM) 与 Diffing 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5-Fiber-%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%8F%AF%E4%B8%AD%E6%96%AD%E3%80%81%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8D%95%E5%85%83"><span class="toc-number">4.1.2.</span> <span class="toc-text">深入 Fiber 架构：可中断、可恢复的渲染单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reconciliation-%E5%8D%8F%E8%B0%83-%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.1.3.</span> <span class="toc-text">Reconciliation (协调) 过程详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%B2%E6%9F%93%E6%8F%AD%E7%A7%98"><span class="toc-number">4.2.</span> <span class="toc-text">并发渲染揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%EF%BC%9F%E5%AE%83%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是并发？它解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#startTransition-%E5%92%8C-useTransition-%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">startTransition 和 useTransition 的原理与应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lane-%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">Lane 模型：任务优先级的内部实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">Hooks 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hooks-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E5%9C%A8%E9%A1%B6%E5%B1%82%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">Hooks 为什么必须在顶层调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState-%E5%92%8C-useEffect-%E7%9A%84%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8-%E2%80%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">useState 和 useEffect 的内部数据结构 (链表)​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3-Hooks-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E2%80%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">从源码角度理解 Hooks 的工作机制​</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%8B"><span class="toc-number">5.</span> <span class="toc-text">相关面试题​</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E2%80%8B"><span class="toc-number">5.1.</span> <span class="toc-text">基础部分​</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E4%B8%8E-React-19-%E9%83%A8%E5%88%86%E2%80%8B"><span class="toc-number">5.2.</span> <span class="toc-text">进阶与 React 19 部分​</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%8E%E7%94%9F%E6%80%81%E9%83%A8%E5%88%86%E2%80%8B"><span class="toc-number">5.3.</span> <span class="toc-text">实战与生态部分​</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E2%80%8B"><span class="toc-number">5.4.</span> <span class="toc-text">原理部分​</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d31147a5/" title="Clawdbot完整配置指南"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo16.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Clawdbot完整配置指南"></a><div class="content"><a class="title" href="/posts/d31147a5/" title="Clawdbot完整配置指南">Clawdbot完整配置指南</a><time datetime="2026-02-11T10:15:08.000Z" title="发表于 2026-02-11 18:15:08">2026-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4d3a9a89/" title="处理 Rancher 连接节点 &quot;Cluster agent is not connected&quot;"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo29.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="处理 Rancher 连接节点 &quot;Cluster agent is not connected&quot;"></a><div class="content"><a class="title" href="/posts/4d3a9a89/" title="处理 Rancher 连接节点 &quot;Cluster agent is not connected&quot;">处理 Rancher 连接节点 &quot;Cluster agent is not connected&quot;</a><time datetime="2026-02-03T06:02:28.000Z" title="发表于 2026-02-03 14:02:28">2026-02-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/nba-logo13.jpg)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2026 By 小五</span><span class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" rel="external nofollow noreferrer" target="_blank"><img src="/img/loading.gif" data-lazy-src="https://img.foreverblog.cn/logo_en_default.png" alt="十年之约" style="width:auto;height:16px"></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/tw_cn.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const e=()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>(e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach(((e,n)=>{const d=e.firstElementChild,a=`mermaid-${n}`,r=`%%{init:{ 'theme':'${t}'}}%%\n`+d.textContent,i=mermaid.render(a,r),m=e=>{d.insertAdjacentHTML("afterend",e)};"string"==typeof i?m(i):i.then((({svg:e})=>m(e)))}))})(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const t=(e,a)=>{"object"==typeof e&&null!==e&&Object.keys(e).forEach((r=>{const n=e[r];"object"==typeof n&&null!==n&&(n[a]?e[r]=n[a]:t(n,a))}))},e=e=>{window.loadChartJS=!0,Array.from(e).forEach(((e,a)=>{const r=e.firstElementChild,n=e.getAttribute("data-chartjs-id")||"chartjs-"+a,d=e.getAttribute("data-width"),o=document.getElementById(n);o&&o.parentNode.remove();const c=r.textContent,l=document.createElement("canvas");l.id=n;const s=document.createElement("div");s.className="chartjs-wrap",d&&(s.style.width=d),s.appendChild(l),r.insertAdjacentElement("afterend",s);const h=document.getElementById(n).getContext("2d"),i=JSON.parse(c),m="dark"===document.documentElement.getAttribute("data-theme")?"dark-mode":"light-mode";(t=>{"dark-mode"===t?(Chart.defaults.color="rgba(255, 255, 255, 0.8)",Chart.defaults.borderColor="rgba(255, 255, 255, 0.2)",Chart.defaults.scale.ticks.backdropColor="transparent"):(Chart.defaults.color="rgba(0, 0, 0, 0.8)",Chart.defaults.borderColor="rgba(0, 0, 0, 0.1)",Chart.defaults.scale.ticks.backdropColor="transparent")})(m),t(i,m),new Chart(h,i)}))},a=()=>{const t=document.querySelectorAll("#article-container .chartjs-container");0!==t.length&&(window.loadChartJS?e(t):btf.getScript("https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js").then((()=>e(t))))};btf.addGlobalFn("themeChange",a,"chartjs"),btf.addGlobalFn("encrypt",a,"chartjs"),window.pjax?a():document.addEventListener("DOMContentLoaded",a)})()</script></div><div class="aplayer no-destroy" data-id="9061017364" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="false" muted></div><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>网站已更新最新版本</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/diytitle.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/metingjs/dist/Meting.min.js"></script><script>btf.addGlobalFn("pjaxSend",(()=>{if(window.aplayers)for(let a=0;a<window.aplayers.length;a++)window.aplayers[a].options.fixed||window.aplayers[a].destroy()}),"destroyAplayer"),btf.addGlobalFn("pjaxComplete",loadMeting,"runMetingJS")</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/talking/"]):not([href="/artitalk/"])',selectors:['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:description"]','link[rel="canonical"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!0,scrollRestoration:!1});const e=e=>{e&&Object.values(e).forEach((e=>{try{e()}catch(e){console.debug("Pjax callback failed:",e)}}))};document.addEventListener("pjax:send",(()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");const t=document.body.classList;t.contains("read-mode")&&t.remove("read-mode"),e(window.globalFn.pjaxSend)})),document.addEventListener("pjax:complete",(()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),a=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(a)),e.parentNode.replaceChild(t,e)})),e(window.globalFn.pjaxComplete)})),document.addEventListener("pjax:error",(e=>{if(404===e.request.status){!0?pjax.loadUrl("/404"):window.location.href="/404"}}))})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div id="algolia-search-input"><div class="ais-SearchBox"><form class="ais-SearchBox-form" action="" role="search" novalidate><input class="ais-SearchBox-input" type="search" placeholder="搜索文章" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" maxlength="512" aria-label="Search"><button class="ais-SearchBox-submit" type="submit" title="Submit the search query" style="display:none"><svg class="ais-SearchBox-submitIcon" width="10" height="10" viewBox="0 0 40 40" aria-hidden="true"><path d="M26.804 29.01c-2.832 2.34-6.465 3.746-10.426 3.746C7.333 32.756 0 25.424 0 16.378 0 7.333 7.333 0 16.378 0c9.046 0 16.378 7.333 16.378 16.378 0 3.96-1.406 7.594-3.746 10.426l10.534 10.534c.607.607.61 1.59-.004 2.202-.61.61-1.597.61-2.202.004L26.804 29.01zm-10.426.627c7.323 0 13.26-5.936 13.26-13.26 0-7.32-5.937-13.257-13.26-13.257C9.056 3.12 3.12 9.056 3.12 16.378c0 7.323 5.936 13.26 13.258 13.26z"></path></svg></button></form></div><hr><div id="algolia-search-results"><div id="algolia-hits"><div id="algolia-hits-empty" style="display:none"></div><div class="ais-Hits" style="display:none"><ol class="ais-Hits-list"></ol></div></div><div class="ais-Pagination" id="algolia-pagination" style="display:none"><ul class="ais-Pagination-list"></ul></div><div id="algolia-info"><span class="ais-Stats-text"></span><a class="algolia-poweredBy" href="https://www.algolia.com/?utm_source=algoliasearch.js&amp;utm_medium=website&amp;utm_content=localhost&amp;utm_campaign=poweredby" target="_blank" aria-label="Search by Algolia" rel="noopener noreferrer"><svg class="ais-PoweredBy-logo" height="1.2em" viewBox="0 0 572 64" style="width:auto"><path fill="#36395A" d="M16 48.3c-3.4 0-6.3-.6-8.7-1.7A12.4 12.4 0 0 1 1.9 42C.6 40 0 38 0 35.4h6.5a6.7 6.7 0 0 0 3.9 6c1.4.7 3.3 1.1 5.6 1.1 2.2 0 4-.3 5.4-1a7 7 0 0 0 3-2.4 6 6 0 0 0 1-3.4c0-1.5-.6-2.8-1.9-3.7-1.3-1-3.3-1.6-5.9-1.8l-4-.4c-3.7-.3-6.6-1.4-8.8-3.4a10 10 0 0 1-3.3-7.9c0-2.4.6-4.6 1.8-6.4a12 12 0 0 1 5-4.3c2.2-1 4.7-1.6 7.5-1.6s5.5.5 7.6 1.6a12 12 0 0 1 5 4.4c1.2 1.8 1.8 4 1.8 6.7h-6.5a6.4 6.4 0 0 0-3.5-5.9c-1-.6-2.6-1-4.4-1s-3.2.3-4.4 1c-1.1.6-2 1.4-2.6 2.4-.5 1-.8 2-.8 3.1a5 5 0 0 0 1.5 3.6c1 1 2.6 1.7 4.7 1.9l4 .3c2.8.2 5.2.8 7.2 1.8 2.1 1 3.7 2.2 4.9 3.8a9.7 9.7 0 0 1 1.7 5.8c0 2.5-.7 4.7-2 6.6a13 13 0 0 1-5.6 4.4c-2.4 1-5.2 1.6-8.4 1.6Zm35.6 0c-2.6 0-4.8-.4-6.7-1.3a13 13 0 0 1-4.7-3.5 17.1 17.1 0 0 1-3.6-10.4v-1c0-2 .3-3.8 1-5.6a13 13 0 0 1 7.3-8.3 15 15 0 0 1 6.3-1.4A13.2 13.2 0 0 1 64 24.3c1 2.2 1.6 4.6 1.6 7.2V34H39.4v-4.3h21.8l-1.8 2.2c0-2-.3-3.7-.9-5.1a7.3 7.3 0 0 0-2.7-3.4c-1.2-.7-2.7-1.1-4.6-1.1s-3.4.4-4.7 1.3a8 8 0 0 0-2.9 3.6c-.6 1.5-.9 3.3-.9 5.4 0 2 .3 3.7 1 5.3a7.9 7.9 0 0 0 2.8 3.7c1.3.8 3 1.3 5 1.3s3.8-.5 5.1-1.3c1.3-1 2.1-2 2.4-3.2h6a11.8 11.8 0 0 1-7 8.7 16 16 0 0 1-6.4 1.2ZM80 48c-2.2 0-4-.3-5.7-1a8.4 8.4 0 0 1-3.7-3.3 9.7 9.7 0 0 1-1.3-5.2c0-2 .5-3.8 1.5-5.2a9 9 0 0 1 4.3-3.1c1.8-.7 4-1 6.7-1H89v4.1h-7.5c-2 0-3.4.5-4.4 1.4-1 1-1.6 2.1-1.6 3.6s.5 2.7 1.6 3.6c1 1 2.5 1.4 4.4 1.4 1.1 0 2.2-.2 3.2-.7 1-.4 1.9-1 2.6-2 .6-1 1-2.4 1-4.2l1.7 2.1c-.2 2-.7 3.8-1.5 5.2a9 9 0 0 1-3.4 3.3 12 12 0 0 1-5.3 1Zm9.5-.7v-8.8h-1v-10c0-1.8-.5-3.2-1.4-4.1-1-1-2.4-1.4-4.2-1.4a142.9 142.9 0 0 0-10.2.4v-5.6a74.8 74.8 0 0 1 8.6-.4c3 0 5.5.4 7.5 1.2s3.4 2 4.4 3.6c1 1.7 1.4 4 1.4 6.7v18.4h-5Zm12.9 0V17.8h5v12.3h-.2c0-4.2 1-7.4 2.8-9.5a11 11 0 0 1 8.3-3.1h1v5.6h-2a9 9 0 0 0-6.3 2.2c-1.5 1.5-2.2 3.6-2.2 6.4v15.6h-6.4Zm34.4 1a15 15 0 0 1-6.6-1.3c-1.9-.9-3.4-2-4.7-3.5a15.5 15.5 0 0 1-2.7-5c-.6-1.7-1-3.6-1-5.4v-1c0-2 .4-3.8 1-5.6a15 15 0 0 1 2.8-4.9c1.3-1.5 2.8-2.6 4.6-3.5a16.4 16.4 0 0 1 13.3.2c2 1 3.5 2.3 4.8 4a12 12 0 0 1 2 6H144c-.2-1.6-1-3-2.2-4.1a7.5 7.5 0 0 0-5.2-1.7 8 8 0 0 0-4.7 1.3 8 8 0 0 0-2.8 3.6 13.8 13.8 0 0 0 0 10.3c.6 1.5 1.5 2.7 2.8 3.6s2.8 1.3 4.8 1.3c1.5 0 2.7-.2 3.8-.8a7 7 0 0 0 2.6-2c.7-1 1-2 1.2-3.2h6.2a11 11 0 0 1-2 6.2 15.1 15.1 0 0 1-11.8 5.5Zm19.7-1v-40h6.4V31h-1.3c0-3 .4-5.5 1.1-7.6a9.7 9.7 0 0 1 3.5-4.8A9.9 9.9 0 0 1 172 17h.3c3.5 0 6 1.1 7.9 3.5 1.7 2.3 2.6 5.7 2.6 10v16.8h-6.4V29.6c0-2.1-.6-3.8-1.8-5a6.4 6.4 0 0 0-4.8-1.8c-2 0-3.7.7-5 2a7.8 7.8 0 0 0-1.9 5.5v17h-6.4Zm63.8 1a12.2 12.2 0 0 1-10.9-6.2 19 19 0 0 1-1.8-7.3h1.4v12.5h-5.1v-40h6.4v19.8l-2 3.5c.2-3.1.8-5.7 1.9-7.7a11 11 0 0 1 4.4-4.5c1.8-1 3.9-1.5 6.1-1.5a13.4 13.4 0 0 1 12.8 9.1c.7 1.9 1 3.8 1 6v1c0 2.2-.3 4.1-1 6a13.6 13.6 0 0 1-13.2 9.4Zm-1.2-5.5a8.4 8.4 0 0 0 7.9-5c.7-1.5 1.1-3.3 1.1-5.3s-.4-3.8-1.1-5.3a8.7 8.7 0 0 0-3.2-3.6 9.6 9.6 0 0 0-9.2-.2 8.5 8.5 0 0 0-3.3 3.2c-.8 1.4-1.3 3-1.3 5v2.3a9 9 0 0 0 1.3 4.8 9 9 0 0 0 3.4 3c1.4.7 2.8 1 4.4 1Zm27.3 3.9-10-28.9h6.5l9.5 28.9h-6Zm-7.5 12.2v-5.7h4.9c1 0 2-.1 2.9-.4a4 4 0 0 0 2-1.4c.4-.7.9-1.6 1.2-2.7l8.6-30.9h6.2l-9.3 32.4a14 14 0 0 1-2.5 5 8.9 8.9 0 0 1-4 2.8c-1.5.6-3.4.9-5.6.9h-4.4Zm9-12.2v-5.2h6.4v5.2H248Z"></path><path fill="#003DFF" d="M534.4 9.1H528a.8.8 0 0 1-.7-.7V1.8c0-.4.2-.7.6-.8l6.5-1c.4 0 .8.2.9.6v7.8c0 .4-.4.7-.8.7zM428 35.2V.8c0-.5-.3-.8-.7-.8h-.2l-6.4 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.5 0 .8-.4.8-.8V43c0-.4-.3-.7-.6-.8-4.5-.5-4.5-6-4.5-7zm106.5-21.8H528c-.4 0-.7.4-.7.8v34c0 .4.3.8.7.8h6.5c.4 0 .8-.4.8-.8v-34c0-.5-.4-.8-.8-.8zm-17.7 21.8V.8c0-.5-.3-.8-.8-.8l-6.5 1c-.4 0-.7.4-.7.8v35c0 1.6 0 11.8 12.3 12.2.4 0 .8-.4.8-.8V43c0-.4-.3-.7-.7-.8-4.4-.5-4.4-6-4.4-7zm-22.2-20.6a16.5 16.5 0 0 1 8.6 9.3c.8 2.2 1.3 4.8 1.3 7.5a19.4 19.4 0 0 1-4.6 12.6 14.8 14.8 0 0 1-5.2 3.6c-2 .9-5.2 1.4-6.8 1.4a21 21 0 0 1-6.7-1.4 15.4 15.4 0 0 1-8.6-9.3 21.3 21.3 0 0 1 0-14.4 15.2 15.2 0 0 1 8.6-9.3c2-.8 4.3-1.2 6.7-1.2s4.6.4 6.7 1.2zm-6.7 27.6c2.7 0 4.7-1 6.2-3s2.2-4.3 2.2-7.8-.7-6.3-2.2-8.3-3.5-3-6.2-3-4.7 1-6.1 3c-1.5 2-2.2 4.8-2.2 8.3s.7 5.8 2.2 7.8 3.5 3 6.2 3zm-88.8-28.8c-6.2 0-11.7 3.3-14.8 8.2a18.6 18.6 0 0 0 4.8 25.2c1.8 1.2 4 1.8 6.2 1.7s.1 0 .1 0h.9c4.2-.7 8-4 9.1-8.1v7.4c0 .4.3.7.8.7h6.4a.7.7 0 0 0 .7-.7V14.2c0-.5-.3-.8-.7-.8h-13.5zm6.3 26.5a9.8 9.8 0 0 1-5.7 2h-.5a10 10 0 0 1-9.2-14c1.4-3.7 5-6.3 9-6.3h6.4v18.3zm152.3-26.5h13.5c.5 0 .8.3.8.7v33.7c0 .4-.3.7-.8.7h-6.4a.7.7 0 0 1-.8-.7v-7.4c-1.2 4-4.8 7.4-9 8h-.1a4.2 4.2 0 0 1-.5.1h-.9a10.3 10.3 0 0 1-7-2.6c-4-3.3-6.5-8.4-6.5-14.2 0-3.7 1-7.2 3-10 3-5 8.5-8.3 14.7-8.3zm.6 28.4c2.2-.1 4.2-.6 5.7-2V21.7h-6.3a9.8 9.8 0 0 0-9 6.4 10.2 10.2 0 0 0 9.1 13.9h.5zM452.8 13.4c-6.2 0-11.7 3.3-14.8 8.2a18.5 18.5 0 0 0 3.6 24.3 10.4 10.4 0 0 0 13 .6c2.2-1.5 3.8-3.7 4.5-6.1v7.8c0 2.8-.8 5-2.2 6.3-1.5 1.5-4 2.2-7.5 2.2l-6-.3c-.3 0-.7.2-.8.5l-1.6 5.5c-.1.4.1.8.5 1h.1c2.8.4 5.5.6 7 .6 6.3 0 11-1.4 14-4.1 2.7-2.5 4.2-6.3 4.5-11.4V14.2c0-.5-.4-.8-.8-.8h-13.5zm6.3 8.2v18.3a9.6 9.6 0 0 1-5.6 2h-1a10.3 10.3 0 0 1-8.8-14c1.4-3.7 5-6.3 9-6.3h6.4zM291 31.5A32 32 0 0 1 322.8 0h30.8c.6 0 1.2.5 1.2 1.2v61.5c0 1.1-1.3 1.7-2.2 1l-19.2-17a18 18 0 0 1-11 3.4 18.1 18.1 0 1 1 18.2-14.8c-.1.4-.5.7-.9.6-.1 0-.3 0-.4-.2l-3.8-3.4c-.4-.3-.6-.8-.7-1.4a12 12 0 1 0-2.4 8.3c.4-.4 1-.5 1.6-.2l14.7 13.1v-46H323a26 26 0 1 0 10 49.7c.8-.4 1.6-.2 2.3.3l3 2.7c.3.2.3.7 0 1l-.2.2a32 32 0 0 1-47.2-28.6z"></path></svg></a></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@5.39.0/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.5.1/source/js/search/algolia.min.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"==location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo3.jpg" alt="/img/nba-logo3.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-02-02</span><a class="blog-slider__title" href="posts/1bcb0ad4/">单环境,多分支并行开发方案(流量染色/istio)</a><div class="blog-slider__text">单环境,多分支并行开发方案(流量染色/istio)</div><a class="blog-slider__button" href="posts/1bcb0ad4/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo22.jpg" alt="/img/nba-logo22.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-06-14</span><a class="blog-slider__title" href="posts/aa43cc95/">记录k8s环境下结合alinode的使用</a><div class="blog-slider__text">记录k8s环境下结合alinode的使用</div><a class="blog-slider__button" href="posts/aa43cc95/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo29.jpg" alt="/img/nba-logo29.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2022-12-13</span><a class="blog-slider__title" href="posts/15957791/">k8s环境下,nginx做websocket负载的方案梳理</a><div class="blog-slider__text">k8s环境下,nginx做websocket负载的方案梳理</div><a class="blog-slider__button" href="posts/15957791/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo22.jpg" alt="/img/nba-logo22.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" href="posts/4ecfb081/">记录一次k8s网络DNS问题排查过程</a><div class="blog-slider__text">记录一次k8s网络DNS问题排查过程</div><a class="blog-slider__button" href="posts/4ecfb081/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo22.jpg" alt="/img/nba-logo22.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" href="posts/37032a87/">k3s高可用安装</a><div class="blog-slider__text">k3s高可用安装</div><a class="blog-slider__button" href="posts/37032a87/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo5.jpg" alt="/img/nba-logo5.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2022-11-27</span><a class="blog-slider__title" href="posts/20b19ed4/">分词搜索需求整理</a><div class="blog-slider__text">分词搜索需求整理</div><a class="blog-slider__button" href="posts/20b19ed4/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo26.jpg" alt="/img/nba-logo26.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2022-12-02</span><a class="blog-slider__title" href="posts/6de14387/">整理wsl2配合开发的一些配置</a><div class="blog-slider__text">整理wsl2配合开发的一些配置</div><a class="blog-slider__button" href="posts/6de14387/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo22.jpg" alt="/img/nba-logo22.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-12-11</span><a class="blog-slider__title" href="posts/fb9adcb6/">记录windows11+wsl2环境搭配</a><div class="blog-slider__text">windows11+wsl2开发环境配置</div><a class="blog-slider__button" href="posts/fb9adcb6/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/loading.gif" data-lazy-src="/img/nba-logo26.jpg" alt="/img/nba-logo26.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2026-01-28</span><a class="blog-slider__title" href="posts/2a9d73ff/">教你如何零成本从0到1，开发上线一个对接了openAI的机器人</a><div class="blog-slider__text">教你如何零成本从0到1，开发上线一个对接了openAI的机器人</div><a class="blog-slider__button" href="posts/2a9d73ff/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';console.log("已挂载swiper"),parent.insertAdjacentHTML("afterbegin",child)}</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:150,height:300,hOffset:20,vOffset:-20},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>